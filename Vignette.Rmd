---
title: "ImputeBench - Vignette"
author: "Robin Richter"
institution: "Deutsches Zentrum fÃ¼r Neurodegenerative Erkrankungen (DZNE) e.V."
date: "15.02.2023"
output: 
  html_document:
    toc: true
    toc_title: "Table of Contents"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(miceadds)
library(mice)
library(ggplot2)
library(plotly)
library(VIM)
library(softImpute)
library(htmltools)
library(htmlwidgets)
library(knitr)
library(missForest)
library(matrixStats)
library(stats)
library(pander)
rm(list = ls())
gc()

source.all(path = "../ImputeBench/R/")

```

```{css, echo=FALSE}
.tab-content>.tab-pane {
display: block;
height: 0px;
overflow: hidden;
padding: 0px
}
.tab-content>.active {
display: block;
height: auto;
padding: 12px
}
```


# 0 Benchmarking Imputation Methods - The ImputeBench Package

This document is a guide through the R package `ImputeBench`. Its purpose is to provide detailed descriptions of the inputs of the main benchmarking functions `data_ImputeBench()` and `simulation_ImputeBench()`, their defaults and how to customize them. It is not a description of the benchmarking protocol, nor a description of the simulation protocol of the data and the missingness pattern, for the detailed definition of these we refer the reader to the accompanying paper RMTBM22. In short `ImputeBench` implements two protocols of benchmarking imputation methods: The first on real, user-provided data and the second on simulated data. The benchmarking protocol in brief: Given parameters on the data and/or missingness pattern simulation for a defined number of repetitions such data and/or missingness-patterns are drawn, the resulting masked matrices are imputed by competing methods and their error compared. Different parameter choices can be passed to the benchmarking functions.

This vignette comprises three chapters:

* **Section 1: Visualization/Plot functions of `ImputeBench`.**

* **Section 2: Benchmarking imputation methods on real data - `data_ImputeBench()`.**

* **Section 3: Benchmarking imputation methods on simulated data - `simulation_ImputeBench()`.**

Find in the following a short introduction to the three sections including overviews of the exported functions and the arguments of the main functions included in `ImputeBench` and where to find details on them in this vignette. To begin with we need to set some global parameters:
```{r, echo = TRUE}
sz = 500
sz.2 = 500
reps = 10
```


## 0.1 Visualization/Plot Functions

Imputation, in particular of high dimensional data, wants to be performed carefully as the creation of signal not supported by the observed data values by imputing is the nightmare of any data analyst. Hence, visual checks of the assumptions made by and the results of imputation algorithms are of crucial importance as sanity checks of the (imputed) data. To this end, in `ImputeBench` multiple plot functions using `ggplot2` or `plotly` are included that should help visualizing the (simulated) data, the (simulated) missingness pattern, the imputed values, as well as, the benchmarking performance of the imputation methods via the benchmarking protocols of `ImputeBench`. The following table provides an overview of all plot functions included in `ImputeBench`. A detailed description follows in Section 1 of this vignette.


```{r table-one, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
panderOptions('table.split.table', Inf)
set.caption("Overview of Plot Functions Included in ImputeBench")
my.data <- " 
  Function                           | Section | Dim. | Data | Miss. Pattern | Miss. Data | Imp. Data  | Mult. Methods | Description 
  `plot_amount_missing`              | 1.1     | -    | no   | yes           | no         | no         | -             | Amount of missing entries          
  `plot_missingness_over_variables`  | 1.1     | -    | no   | yes           | no         | no         | -             | Distribution of missing entries 
  `plot_sigmoid`                     | 2.1.1   | -    | no   | no            | no         | no         | -             | sigmoid used in data simulation 
  `plot_ImputeBench`                 | 2.5/3.5 | -    | no   | no            | no         | no         | yes           | benchmarking performance
  `plot_1D_data`                     | 1.2     | 1    | yes  | no            | no         | no         | -             | data distribution
  `plot_2D_data`                     | 1.2     | 2    | yes  | no            | no         | no         | -             | data distribution
  `plot_3D_data`                     | 1.2     | 3    | yes  | no            | no         | no         | -             | data distribution
  `plot_1D_real_missingness`         | 1.3     | 1    | yes  | yes           | no         | no         | -             | missing entries distribution w.r.t. data distribution
  `plot_2D_real_missingness`         | 1.3     | 2    | yes  | yes           | no         | no         | -             | missing entries distribution w.r.t. data distribution
  `plot_3D_real_missingness`         | 1.3     | 3    | yes  | yes           | no         | no         | -             | missing entries distribution w.r.t. data distribution  
  `plot_1D_simulated_missingness`    | 1.4     | 1    | yes  | yes           | yes        | no         | -             | missing data distribution  
  `plot_2D_simulated_missingness`    | 1.4     | 2    | yes  | yes           | yes        | no         | -             | missing data distribution    
  `plot_3D_simulated_missingness`    | 1.4     | 3    | yes  | yes           | yes        | no         | -             | missing data distribution    
  `plot_1D_imputed`                  | 1.5     | 1    | yes  | no            | no         | yes        | no            | imputed data distribution w.r.t. data distribution  
  `plot_2D_imputed`                  | 1.5     | 2    | yes  | no            | no         | yes        | no            | imputed data distribution w.r.t. data distribution 
  `plot_3D_imputed`                  | 1.5     | 3    | yes  | no            | no         | yes        | no            | imputed data distribution w.r.t. data distribution 
  `plot_1D_imputed_sim`              | 1.6     | 1    | yes  | yes           | yes        | yes        | yes           | imputed data distribution w.r.t. (missing) data distribution 
  `plot_2D_imputed_sim`              | 1.6     | 2    | yes  | yes           | yes        | yes        | no            | imputed data distribution w.r.t. (missing) data distribution 
  `plot_3D_imputed_sim`              | 1.6     | 3    | yes  | yes           | yes        | yes        | no            | imputed data distribution w.r.t. (missing) data distribution  "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```


## 0.2 Benchmarking Imputation Methods on Real Data

The purpose of the function `data_ImputeBench()` discussed in Section 2 is to attempt answering the question: 

<center>
*Which is the most appropriate imputation method for my data among the ones compared?*
</center>
<br />

The idea in broad terms: Given data with missing entries we want to compare imputation methods on (various) assumptions on the missingness pattern to the end of finding the most suitable one to use on the entries that are actually missing. In the end the output of `data_ImputeBench()` could look as plotted below:


```{r, echo = FALSE, message = FALSE, warnings = FALSE, fig.align = "center"}

data("diamonds")
diamonds.mtrx = as.matrix(diamonds[,c(1,5:10)])
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
#unique(diamonds$cut)
diamonds.mtrx[which(as.character(diamonds$cut) == "Fair"),8] = 1
diamonds.mtrx[which(as.character(diamonds$cut) == "Good"),8] = 2
diamonds.mtrx[which(as.character(diamonds$cut) == "Very Good"),8] = 3
diamonds.mtrx[which(as.character(diamonds$cut) == "Premium"),8] = 4
diamonds.mtrx[which(as.character(diamonds$cut) == "Ideal"),8] = 5
#unique(diamonds$color)
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
diamonds.mtrx[which(as.character(diamonds$color) == "D"),9] = 1
diamonds.mtrx[which(as.character(diamonds$color) == "E"),9] = 2
diamonds.mtrx[which(as.character(diamonds$color) == "F"),9] = 3
diamonds.mtrx[which(as.character(diamonds$color) == "G"),9] = 4
diamonds.mtrx[which(as.character(diamonds$color) == "H"),9] = 5
diamonds.mtrx[which(as.character(diamonds$color) == "I"),9] = 6
diamonds.mtrx[which(as.character(diamonds$color) == "J"),9] = 7
#unique(diamonds$clarity)
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
diamonds.mtrx[which(as.character(diamonds$clarity) == "I1"),10] = 1
diamonds.mtrx[which(as.character(diamonds$clarity) == "SI2"),10] = 2
diamonds.mtrx[which(as.character(diamonds$clarity) == "SI1"),10] = 3
diamonds.mtrx[which(as.character(diamonds$clarity) == "VS2"),10] = 4
diamonds.mtrx[which(as.character(diamonds$clarity) == "VS1"),10] = 5
diamonds.mtrx[which(as.character(diamonds$clarity) == "VVS2"),10] = 6
diamonds.mtrx[which(as.character(diamonds$clarity) == "VVS1"),10] = 7
diamonds.mtrx[which(as.character(diamonds$clarity) == "IF"),10] = 8
colnames(diamonds.mtrx)[8:10] = c("cut","color","clarity")
diamonds.mtrx = diamonds.mtrx[1:sz,c(1,8:10,2:7)]


missingness.scenario = list(MCAR = list(columns = c(2,3,4),
                                        probability = c(0.1,0.2,0.3)),
                            MAR = list(columns = c(8,9,10),
                                       reg.columns = list(6,6,6),
                                       reg.sign = list(1,1,1),
                                       probability.upper = c(0.7,0.7,0.7),
                                       probability.lower = c(0.01,0.01,0.01),
                                       probability.midpoint = list(c(0.7,0.2),
                                                                   c(0.7,0.2),
                                                                   c(0.7,0.2))),
                            MNAR = list(columns = c(1,7),
                                        reg.sign = c(1,1,1),
                                        probability.upper = c(0.8,0.8),
                                        probability.lower = c(0.05,0.05),
                                        probability.midpoint = list(c(0.8,0.2),
                                                                    c(0.8,0.2))))


mask = simulate_mask(data = diamonds.mtrx,
                     scenario = missingness.scenario)

dm_data = add_missing(data = diamonds.mtrx,
                   mask = mask)
colnames(dm_data) = colnames(diamonds.mtrx)

scenarios = list("MCAR + MNAR" = list("MCAR" = list(columns = c(2:4),
                                                    probability = rep(0.2, times = 3)
),
"MNAR" = list(columns = c(1,7:10),
              probability.upper = rep(0.8, times = 5),
              probability.lower = rep(0.2, times = 5),
              probability.midpoint = list(c(0.8,0.25),
                                          c(0.8,0.25),
                                          c(0.8,0.25),
                                          c(0.8,0.25),
                                          c(0.8,0.25))
)
),
"MCAR + MAR" = list("MCAR"  = list(columns = c(2:4),
                                   probability = rep(0.2, times = 3)
),
"MAR" = list(columns = c(1,7:10),
             reg.columns = list(c(7),
                                c(1),
                                c(6),
                                c(6),
                                c(6)),
             probability.upper = rep(0.8, times = 5),
             probability.lower = rep(0.1, times = 5),
             probability.midpoint = list(c(0.6,0.3),
                                         c(0.6,0.3),
                                         c(0.6,0.3),
                                         c(0.6,0.3),
                                         c(0.6,0.3))
)
),
"MCAR + MAR + MNAR" = list("MCAR" = list(columns = c(2:4),
                                         probability = rep(0.33, times = 3)
),
"MAR" = list(columns = c(8:10),
             reg.columns = list(c(6),
                                c(6),
                                c(6)),
             probability.upper = rep(0.8, times = 3),
             probability.lower = rep(0.1, times = 3),
             probability.midpoint = list(c(0.6,0.3),
                                         c(0.6,0.3),
                                         c(0.6,0.3))
),
"MNAR" = list(columns = c(1,7),
              probability.upper = c(0.8,0.8),
              probability.lower = c(0.2,0.2),
              probability.midpoint = list(c(0.8,0.25),
                                          c(0.8,0.25))
)
)
)

wrandom = function(data,
                   args = NULL){
  clms.with.missing.entries = 
    which(matrixStats::colSums2(matrix(as.numeric(is.na(data)), nrow = nrow(data))) != 0)
  imputed.matrix = data
  for(t in clms.with.missing.entries){
    imputed.matrix[is.na(data[,t]),t] = 
      sample(data[!is.na(data[,t]),t], replace = TRUE, size = sum(as.numeric(is.na(data[,t]))))
  }
  return(imputed.matrix)
}

train.random = function(data){
  return(NULL)
}

train.lambda.5 = function(data){
  rank.max = base::min(base::ncol(data),base::nrow(data)) - 1
  return(args = list(lambda = 0.5,
                     rank.max = rank.max,
                     type = "svd"))
} 
wsImpute = function(data,
                    args = list(rank.max = 50,
                                lambda = 2,
                                type = "svd")){
  means = matrixStats::colMeans2(data, na.rm = TRUE)
  sd = matrixStats::colSds(data, na.rm = TRUE)
  data.stdzd = (data - matrix(rep(means, each = nrow(data)), nrow = nrow(data))) /
    matrix(rep(pmax(sd, 0.0001), each = nrow(data)), nrow = nrow(data))
  fits.sI = softImpute::softImpute(data.stdzd ,
                                   rank.max = args$rank.max,
                                   lambda = args$lambda,
                                   type = args$type)
  imputed.matrix = softImpute::complete(data.stdzd, fits.sI)
  
  imputed.matrix = (matrix(rep(pmax(sd, 0.0001), each = nrow(data)), nrow = nrow(data)) * imputed.matrix) +
    matrix(rep(means, each = nrow(data)), nrow = nrow(data))
  
  return(imputed.matrix)
}

methods = list("User Candidate 1" =  wrandom, "User Candidate 2" = wsImpute)
training = list(train.random, train.lambda.5)

Results.4 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios,
                             methods = methods,
                             training = training,
                             verbose = FALSE)

plot_ImputeBench(Evaluation = Results.4$evaluation,
                 title = "Imputation Performance on Data Set 1")


```


In the above plot different imputation methods (color coded; default ones included in `data_ImputeBench()` and user candidate methods) are compared over different assumptions on the missingness pattern (x-axis) by their imputation error normalized by a baseline imputation method (y-axis) over multiple runs of simulating additional missingness pattern. In Section 2 of this vignette we will detail the arguments of `data_ImputeBench()`, how to pass them and their default choices. For the full details of the benchmarking protocol we refer the reader to the accompanying paper RMTBM22. The following tables give an overview of the arguments of `data_ImputeBench()` and over the functions exported by `ImputeBench` in relation to benchmarking imputation methods on real data.


```{r table-two, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
panderOptions('table.split.table', Inf)
set.caption("Overview of the Arguments of `data_ImputeBench()`")
my.data <- " 
  Argument                 | Section | Required? | Type              | Default     | Description
  `data`                   | -       | yes       | matrix            | -           | The data matrix to be analysed (possibly with missing entries)          
  `scenarios`              | 2.1.1   | no        | list of lists     | see 2.1.1   | Missingness Scenarios guiding simulation of the missingness pattern      
  `missingness_parameters` | 2.1.2   | no        | list of lists     | see 2.1.2   | Parameters for drawing missingness scenarios (ignored if `scenarios` are provided)
  `methods`                | 2.2.1   | no        | list of functions | NULL        | User specified imputation methods  
  `training`               | 2.2.2   | no        | list of functions | NULL        | User specified training function for the parameters of the methods in `methods`     
  `default_methods`        | 2.2.3   | no        | vector of strings | see 2.2.4   | Vector naming the defaul imputation methods included    
  `retrain_always`         | 2.2.4   | no        | Boolean           | FALSE       | Indicating the freequency of retraining of the parameters for each method   
  `baseline_method`        | 2.2.5   | no        | c. string         | `\"median\"`| Choice of baseline method
  `error_measure`          | 2.3.1   | no        | c. string         | `\"l2\"`    | Loss function used in the comparison    
  `scaling_robust`         | 2.3.1   | no        | numeric           | 0.1         | Robustness constant for the loss function
  `error_grouping`    | 2.3.2   | no        | list of vectors   | NULL        | Grouping of columns of the `data` for group-wise evaluation    
  `repetitions`            | 2.3.3   | no        | integer           | 5           | Amount of draws of one scenario 
  `seed`                   | 2.4     | no        | integer           | NULL        | Setting a seed
  `max_time`               | 2.4     | no        | integer           | 2592000     | Maximum computation time in seconds for each imputation method  
  `output_data`            | 2.4     | no        | Boolean           | TRUE        | Save and output the drawn and imputed matrices and the trained parameters.
  `verbose`                | 2.4     | no        | Boolean           | FALSE       | Message everytime a repetition of a scenario is done    "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```





```{r table-three, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
panderOptions('table.split.table', Inf)
set.caption("Overview of Exported Functions in Relation to Benchmarking Imputation Methods on Real Data")
my.data <- " 
  Function                               | Section | Description
  `data_ImputeBench`                     | 2       | Main benchmarking function for imputation methods on real data    
  `simulate_mask`                        | 2.1.1   | Simulates missingness patterns from missingness scenarios 
  `add_missing`                          | 2.1.1   | Adding missing entries by a missingness pattern on a data matrix
  `plot_sigmoid`                         | 2.1.1   | Plotting the sigmoid used in drawing the missingness pattern
  `missingness_scenario_from_parameters` | 2.1.2   | Simulates missingness scenarios from missingness parameters 
  `wKNN`                                 | 1.5     | Wrapper function for k-nn (default) 
  `wMICE`                                | 1.5     | Wrapper function for MICE (default) 
  `wmissF`                               | 1.5     | Wrapper function for missForest (default) 
  `wsImpute`                             | 1.5     | Wrapper function for soft impute (default) 
  `baseline_imputation`                  | 1.5     | Function including the baseline imputation
  `round_imputation`                     | 1.5     | Rounding and binarizing imputation results (data-driven)
  `train_KNN`                            | 1.5     | Default training function for k-nn
  `train_sImpute`                        | 1.5     | Default training function for soft impute
  `RMSEscaled_onmask`                    | 2.3.1   | Normalized l2-Loss function 
  `group_RMSEscaled_onmask`              | 2.3.1   | Normalized l2-Loss function with error groups
  `plot_ImputeBench`                     | 2.5/3.5 | Wrapper function to plot the results of `data_ImputeBench`
  `example_ImputeBench`                  | 2.6/3.6 | Wrapper function to extract examples from `data_ImputeBench` "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```



## 0.3 Benchmarking Imputation Methods on Simulated Data

Section 3 discusses the second main benchmarking function `simulation_ImputeBench()`. While `data_ImputeBench()` needs the input of a data set to compare imputation methods on the given data, the function `simulation_ImputeBench()` aims at comparing imputation methods more generally on simulated data. Hence, `simulation_ImputeBench()` is useful to answer questions such as: 

<center>
*Under what data/missingness pattern regime does my new imputation method perform well with respect to existing approaches?* 
</center>
<br />

Additional to assumptions on the missingness pattern underlying their simulation, the user can make tailored assumptions on the data distribution that will guide the data simulation protocol. For the detailed protocol we refer the reader to the accompanying paper RMTBM22. Meanwhile, in Section 3 we will discuss how to pass the different parameters of the data and missingness pattern simulation protocols for `simulation_ImputeBench()`. A possible outcome could look - similar to the example in Section 0.2 - as depicted below, with the x-axis reflecting different choices of parameters on the simulation protocol:


```{r echo=FALSE , message=FALSE, warnings=FALSE, fig.align = "center"}

parameters = list("Sphere" = list(data.size = sz,
                                  data.type = c(10,0,0,0,0,0),
                                  data.low.dim = 3,
                                  data.non.linearity = 1,
                                  data.low.dim.parameters = list(error.std = 0.8)),
                  "Multimodal" = list(data.size = sz,
                                      data.type = c(10,0,0,0,0,0),
                                      data.low.dim = 5,
                                      data.groups = 8,
                                      data.groups.distance = c(1,5)),
                  "Latent Low\nDimension" = list(data.size = sz,
                                                 data.type = c(10,0,0,0,0,0),
                                                 data.low.dim = 1,
                                                 data.low.dim.groups = 10,
                                                 data.low.dim.parameters = list(mean = 6,
                                                                                error.std = 0.5)),
                  "Poisson" = list(data.size = sz,
                                   data.type = c(0,10,0,0,0,0,0),
                                   data.low.dim = 2,
                                   data.non.linearity = 0))


Results.S2 = simulation_ImputeBench(data_parameters = parameters,
                                    methods = methods,
                                    repetitions = reps,
                                    training = training,
                                    verbose = FALSE)


plot_ImputeBench(Evaluation = Results.S2$evaluation,
                 norm_by_baseline = TRUE,
                 title = "Imputation Performance under different Data Regimes")



```

On the other hand one could vary only one of the parameters, such as sample size and obtain a plot like this:     

```{r, echo = FALSE, message = FALSE, warnings = FALSE, fig.align = "center"}

parameters.2 = list("Par 1" = list(data.size = 100,
                                   data.type = c(20,0,0,0,0,0),
                                   data.low.dim = 3,
                                   data.non.linearity = 1,
                                   data.low.dim.parameters = list(error.std = 0.8)),
                    "Par 2" = list(data.size = 200,
                                   data.type = c(20,0,0,0,0,0),
                                   data.low.dim = 3,
                                   data.non.linearity = 1,
                                   data.low.dim.parameters = list(error.std = 0.8)),
                    "Par 3" = list(data.size = 400,
                                   data.type = c(20,0,0,0,0,0),
                                   data.low.dim = 3,
                                   data.non.linearity = 1,
                                   data.low.dim.parameters = list(error.std = 0.8)))

Results.S3 = simulation_ImputeBench(data_parameters = parameters.2,
                                    methods = methods,
                                    repetitions = reps,
                                    training = training,
                                    verbose = FALSE)

plot_ImputeBench(Evaluation = Results.S3$evaluation,
                 title = "Imputation Performance in Relation to Sample Size",
                 x_axis = "n")



```              


The arguments and functionality of `simulation_ImputeBench()` is in large parts similar to those of `data_ImputeBench()`, hence, to avoid repetitions, arguments that work basically the same as in `data_ImputeBench()` are discussed in their respective subsections of Section 2 in detail and only differences are highlighted in Section 3. Below one finds a list of the arguments of `simulation_ImputeBench()` and a list of additionally exported functions, both with reference to where they are discussed in this vignette.


```{r table-four, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
panderOptions('table.split.table', Inf)
set.caption("Overview of the Arguments of `simulation_ImputeBench()`")
my.data <- " 
  Argument                 | Section      | Required? | Type              | Default     | Description
  `data_parameters`        | 3.1.1        | no        | list of lists     | see 3.1.1   | Parameters guiding the data simulation protocol         
  `missingness_parameters` | 2.1.2 (3.1.2)| no        | list of lists     | see 2.1.2   | Parameters for drawing missingness scenarios underlying the missingness pattern simulation protocol
  `methods`                | 2.2.1 (3.2)  | no        | list of functions | NULL        | User specified imputation methods  
  `training`               | 2.2.2 (3.2)  | no        | list of functions | NULL        | User specified training function for the parameters of the methods in `methods`     
  `default_methods`        | 2.2.3 (3.2)  | no        | vector of strings | see 2.3.4   | Vector naming the defaul imputation methods included    
  `retrain_always`         | 2.2.4 (3.2)  | no        | Boolean           | FALSE       | Indicating the freequency of retraining of the parameters for each method   
  `baseline_method`        | 2.2.5 (3.2)  | no        | c. string         | `\"median\"`| Choice of baseline method
  `error_measure`          | 2.3.1 (3.3)  | no        | c. string         | `\"l2\"`    | Loss function used in the comparison    
  `scaling_robust`         | 2.3.1 (3.3)  | no        | numeric           | 0.1         | Robustness constant for the loss function
  `repetitions`            | 2.3.3 (3.3)  | no        | integer           | 5           | Amount of draws of one scenario 
  `seed`                   | 3.4          | no        | integer           | NULL        | Setting a seed
  `max_time`               | 3.4          | no        | integer           | 2592000     | Maximum computation time in seconds for each imputation method  
  `output_data`            | 3.4          | no        | Boolean           | TRUE        | Save and output the drawn and imputed matrices and the trained parameters.
  `verbose`                | 3.4          | no        | Boolean           | FALSE       | Message everytime a repetition of a scenario is done    "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```



```{r table-five, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
panderOptions('table.split.table', Inf)
set.caption("Overview of Exported Functions in Relation to Benchmarking Imputation Methods on Simulated Data")
my.data <- " 
  Function                               | Section | Description
  `simulation_ImputeBench`               | 3       | Main benchmarking function for imputation methods on simulated data   
  `simulate_data`                        | 3.1.1   | Simulated data according to the data simulation protocol
  `simulate_mask`                        | 2.1.1   | Simulates missingness patterns from missingness scenarios 
  `add_missing`                          | 2.1.1   | Adding missing entries by a missingness pattern on a data matrix
  `plot_sigmoid`                         | 2.1.1   | Plotting the sigmoid used in drawing the missingness pattern
  `wKNN`                                 | 1.5     | Wrapper function for k-nn (default) 
  `wMICE`                                | 1.5     | Wrapper function for MICE (default) 
  `wmissF`                               | 1.5     | Wrapper function for missForest (default) 
  `wsImpute`                             | 1.5     | Wrapper function for soft impute (default) 
  `baseline_imputation`                  | 1.5     | Function including the baseline imputation
  `round_imputation`                     | 1.5     | Rounding and binarizing imputation results (data-driven)
  `train_KNN`                            | 1.5     | Default training function for k-nn
  `train_sImpute`                        | 1.5     | Default training function for soft impute
  `RMSEscaled_onmask`                    | 2.3.1   | Normalized l2-Loss function 
  `group_RMSEscaled_onmask`              | 2.3.1   | Normalized l2-Loss function with error groups
  `plot_ImputeBench`                     | 2.5/3.5 | Wrapper function to plot the results of `simulation_ImputeBench`
  `example_ImputeBench`                  | 2.6/3.6 | Wrapper function to extract examples from `simulation_ImputeBench` "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```



# 1 Visualization with `ImputeBench`

`ImputeBench` includes various plot function using either the package `ggplot2` or the package `plotly` (for 3D plots). There are some ways to customize these plots, however limited to a few arguments. For complete customization of plots we recommend to create new plots with `ggplot2` or `plotly` using the results of `data_ImputeBench()` and `simulation_ImputeBench()` directly. However, in particular when created for analyzing and processing the data or method at hand rather than for publishing we found it to be necessary that `ImputeBench` contains plot functions that do the job quickly without much effort. This section gives an overview of the plot functions included in `ImputeBench` with the exception of `plot_ImputeBench()` (plotting the results of the benchmarking protocol) which is discussed in detail in Section 2.5 and 3.5, and `plot_sigmoid()` which is discussed in Section 2.1.1. In the case you are interested in the benchmarking functions only, you can safely skip ahead to Section 2 of this vignette, as most of the plots are self-explanatory.

**Note 1.1:**: In the following a variable is deemed discrete if and only if their entries are all integers and it is called continuous if that is not the case.

**Note 1.2**: All plot functions discussed in Section 1 expect a numeric matrix being passed via the argument `data` (possibly with missing entries indicated by `NA`).

**Note 1.3**: For all plot functions the argument `title` can be passed, expecting a character string, changing the default title of the plot.

The example that we will resort to for illustration in this and the following sections is the `diamonds` data of `ggplot2`. To our purposes we trim it and translate the entries into numeric entries :

```{r, echo = TRUE, fig.align = "center"}
library(ggplot2)
data("diamonds")
diamonds.mtrx = as.matrix(diamonds[,c(1,5:10)])
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
# Translate cut
diamonds.mtrx[which(as.character(diamonds$cut) == "Fair"),8] = 1
diamonds.mtrx[which(as.character(diamonds$cut) == "Good"),8] = 2
diamonds.mtrx[which(as.character(diamonds$cut) == "Very Good"),8] = 3
diamonds.mtrx[which(as.character(diamonds$cut) == "Premium"),8] = 4
diamonds.mtrx[which(as.character(diamonds$cut) == "Ideal"),8] = 5
# Translate color
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
diamonds.mtrx[which(as.character(diamonds$color) == "D"),9] = 1
diamonds.mtrx[which(as.character(diamonds$color) == "E"),9] = 2
diamonds.mtrx[which(as.character(diamonds$color) == "F"),9] = 3
diamonds.mtrx[which(as.character(diamonds$color) == "G"),9] = 4
diamonds.mtrx[which(as.character(diamonds$color) == "H"),9] = 5
diamonds.mtrx[which(as.character(diamonds$color) == "I"),9] = 6
diamonds.mtrx[which(as.character(diamonds$color) == "J"),9] = 7
# Translate clarity
diamonds.mtrx = cbind(diamonds.mtrx, rep(0, times = nrow(diamonds.mtrx)))
diamonds.mtrx[which(as.character(diamonds$clarity) == "I1"),10] = 1
diamonds.mtrx[which(as.character(diamonds$clarity) == "SI2"),10] = 2
diamonds.mtrx[which(as.character(diamonds$clarity) == "SI1"),10] = 3
diamonds.mtrx[which(as.character(diamonds$clarity) == "VS2"),10] = 4
diamonds.mtrx[which(as.character(diamonds$clarity) == "VS1"),10] = 5
diamonds.mtrx[which(as.character(diamonds$clarity) == "VVS2"),10] = 6
diamonds.mtrx[which(as.character(diamonds$clarity) == "VVS1"),10] = 7
diamonds.mtrx[which(as.character(diamonds$clarity) == "IF"),10] = 8
colnames(diamonds.mtrx)[8:10] = c("cut","color","clarity")
diamonds.mtrx = diamonds.mtrx[1:sz,c(1,8:10,2:7)]
summary(diamonds.mtrx)
```

Now we need to add some missingness, we will do this via the exported functions `simulate_mask()` and `add_missing()` which takes as an input a missingess scenario, both of which are discussed in details in Section 2.1.1, for now we will compute the mask and mask the data uncommented:

```{r, echo = TRUE, fig.align = "center"}

missingness.scenario = list(MCAR = list(columns = c(2,3,4),
                                        probability = c(0.1,0.2,0.3)),
                            MAR = list(columns = c(8,9,10),
                                       reg.columns = list(6,6,6),
                                       reg.sign = list(1,1,1),
                                       probability.upper = c(0.7,0.7,0.7),
                                       probability.lower = c(0.01,0.01,0.01),
                                       probability.midpoint = list(c(0.7,0.2),
                                                                   c(0.7,0.2),
                                                                   c(0.7,0.2))),
                            MNAR = list(columns = c(1,7),
                                        reg.sign = c(1,1,1),
                                        probability.upper = c(0.8,0.8),
                                        probability.lower = c(0.05,0.05),
                                        probability.midpoint = list(c(0.8,0.2),
                                                                    c(0.8,0.2))))

mask = simulate_mask(data = diamonds.mtrx,
                     scenario = missingness.scenario)

dm_data = add_missing(data = diamonds.mtrx,
                   mask = mask)
colnames(dm_data) = colnames(diamonds.mtrx)

```

In the remainder of the vignette we will consider the diamonds data (`dm_data`) as a real data set whose missing values are *not* known. 


## 1.1 Visualizing the Distribution of Missing Entries over the Columns

  * **Functions**: `plot_amount_missing_entries()` and `plot_missingness_over_variables()`.
  * **Target**: Data matrix with missing entries.
  * **Purpose**: Visualize the distribution of missing entries over the columns.

### Plotting the Amount of Missing Entries per Variable

The function `plot_amount_missing_entries()` returns - when passed a data matrix with missing entries by the argument `data` - an overview of the amount of missing entries in each column or in groups of columns. There are two different kind of plots produced by `plot_amoung_missing_entries()` controlled by the argumnet `groups`. 

#### Example - Without Column Grouping (`groups = NULL`; default) {.tabset}

By default - that is `groups = NULL` - `plot_amount_missing_entries` returns a scatter plot (with random jitter on the x-axis) of the amount of missing values in each column (y-axis) and with points over a specified threshold of missing entries labeled by their column/variable name. In particular when dealing with a large number of columns this plot aims at giving a quick overview of the amount of missing entries per column/variable. Arguments that customize this plot and can be passed are:

* `jitter`: The amount of jitter on the x-axis. Default is `0.4`.
* `alpha`: The transparency of the points. Default is `1`.
* `thres_name`: The threshold deciding which column names should be displayed. Default is `0.05`.
* `y_axis`: The labeling on the y-axis. Expected are either `"percent"` or `"amount"`. Default is `"percent"`.
* `seed`: To fix the jitter. Default is `NULL`.

##### With Jitter

```{r, echo = TRUE}

plot_amount_missing_entries(dm_data,
                            thres_name = 0,
                            seed = 2)
```

##### Without Jitter
```{r, echo = TRUE, fig.align = "center"}
plot_amount_missing_entries(dm_data,
                            thres_name = 0,
                            seed = 2,
                            jitter = 0)

```

#### Example - With Column Grouping {.tabset}

Via passing a list to the `groups` argument one can create a boxplot/dotplot over the amount of missing entries in each column of the given group. The `groups` argument is expected to be a named list of column indices, for an example consider the following grouping of the diamonds columns:


```{r, echo = TRUE}
grouping = list("value" = c(1,7),
                "specifications" = c(2,3,4,5),
                "table" = c(6),
                "dimensions" = c(8,9,10))
```

If passed to `plot_amount_missing_entries()` the groups constitute the x-axis of a box or dotplot displaying summary statistics of the amount of missing entries in each groups. The type of summary statistic can be controlled by the additional input `type`, which can be one of `"box"` (displaying a boxplot of the distribution of the amount of missing entries in each column of the group), `"total"` (displaying a dotplot with the amount of missing entries in the whole group (adding up all counts of missing entries over the columns); the choice `y.axis = "percent"` is not available) and `"mean"` (displaying a dotplot with the mean amount of missing entries over the columns in the group).

*Tip:* It is possible to define a grouping with one column index per group.


##### Boxplot of Missingness per Column (default)

```{r, echo = TRUE, fig.align = "center"}
plot_amount_missing_entries(dm_data,
                            thres_name = 0,
                            groups = grouping,
                            type = "box")

```

##### Dotplot of the Total Amounts of Missing Entries

```{r, echo = TRUE, fig.align = "center"}

plot_amount_missing_entries(dm_data,
                            thres_name = 0,
                            groups = grouping,
                            type = "total")
```

##### Dotplot of the Mean Amount of Missingness per Column

```{r, echo = TRUE, fig.align = "center"}
plot_amount_missing_entries(dm_data,
                            thres_name = 0,
                            groups = grouping,
                            type = "mean")

```



### Plotting the Distribution of the Amount of Missing Entries

The function `plot_missingness_over_variables()` plots the distribution of the amount of missingness per variable. This is particularly useful when the column size is rather large and one wants to have a better overview of the distribution than via boxplots in `plot_amount_missing_entries()`.

By default a bar plot is plotted whose `binwidth` can be customized. Moreover, via the `x_axis` argument one can change the x-axis labels and title from displaying percentages (`= "percent"`) to displaying the total amount of missing entries (`= "amount"`). If via the `groups` variable a grouping is passed (analogously to `plot_amount_missing_entries()`) the plot is faceted according to the groups.

#### Example {.tabset}

##### Without Column Grouping (default)

```{r, echo = TRUE, warning = FALSE}
plot_missingness_over_variables(data = dm_data)
```

##### With Column Grouping

```{r, echo = TRUE, warning = FALSE}

grouping = list("Group A" = c(1,2,3,4,5,6),
                "Group B" = c(7,8,9,10))
plot_missingness_over_variables(data = dm_data,
                                groups = grouping)

```



## 1.2 Visualizing the data

  * **Functions**: `plot_1D_data()`, `plot_2D_data()` and `plot_3D_data()`.
  * **Target**: Data matrix.
  * **Purpose**: Visualize the data distribution.

Note that this family of plot functions is particularly interesting when data is simulated as in Section 3, since visual inspection often gives more insights how the single data parameters influence the data simulation protocol compared to the equations that guide them. The family consists of three functions `plot_1D_data()`, `plot_2D_data()` and `plot_3D_data()`, each plotting the data for a specific set of columns, specified via the variable `clm` or `clms` for the 1D or the 2D/3D case, respectively (`clm` and `clms` expect positive integers). 

**Note 1.4**: Rows with missing entries are ignored by `plot_1D_data()`, `plot_2D_data()` and `plot_3D_data()`. In the example below we use the incomplete diamonds data (`dm_data`), hence all incomplete rows of `clm`/`clms` are discarded. 

### Example {.tabset}

#### 1D {.tabset}

##### carat
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 1,
             binwidth = 0.01)
```

##### cut
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data =dm_data,
             clm = 2)
```

##### color
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data =dm_data,
             clm = 3)
```

##### clarity
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data =dm_data,
             clm = 4)
```

##### depth
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 5,
             binwidth = 0.1)
```

##### table
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 6,
             binwidth = 1)
```

##### price
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 7,
             binwidth = 10)
```

##### x
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 8,
             binwidth = 0.01)
```

##### y
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 9,
             binwidth = 0.01)
```

##### z
```{r, echo = TRUE, fig.align = "center"}
plot_1D_data(data = dm_data,
             clm = 10,
             binwidth = 0.01)
```

#### 2D {.tabset}

##### carat & cut
```{r, echo = TRUE, fig.align = "center"}
plot_2D_data(data = dm_data,
             clms = c(1,2),
             jitter = 0.2)
```

##### color & clarity
```{r, echo = TRUE, fig.align = "center"}
plot_2D_data(data = dm_data,
             clms = c(3,4),
             type = "tile")
```

##### depth & table
```{r, echo = TRUE, fig.align = "center"}
plot_2D_data(data = dm_data,
             clms = c(5,6),
             alpha = 0.1)
```

##### price & x
```{r, echo = TRUE, fig.align = "center"}
plot_2D_data(data = dm_data,
             clms = c(7,8))
```

##### y & z
```{r, echo = TRUE, fig.align = "center"}
plot_2D_data(data = dm_data,
             clms = c(9,10))
```

#### 3D {.tabset}

##### carat $ cut & color
```{r, echo = TRUE, fig.align = "center"}
plot_3D_data(data = dm_data,
             clms = c(1,2,3),
             type = "facets")
```

<!-- ###### clarity & depth & table -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_data(data = dm_data, -->
<!--                  clms = c(4,5,6)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_1_cdt.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_1_cdt.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->


##### price & x & y
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_data(data = dm_data,
                 clms = c(7,8,9))
p
```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_1_xyz.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_1_xyz.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

### Description

In 1D the resulting plot is a histogram of the empirical distribution that can be customized by passing the variable `binwidth` (default is `nrow(data)/30`). Meanwhile, in the 2D case the default plot is a scatter plot (with customizable `jitter` and `alpha`; defaults are `0.4` and `0.25`, respectively) that can be change into a tile-plot for two discrete variables with `type = "tile"`. Note that by default jitter is added to the scatter plot, this can be changed by choosing `jitter = 0` (Observe that the variable `table` of `dm_data` above is *not* discrete). Last, for the 3D plots the default is a plotly-3D-scatter plot (with automatically added jitter in case of discrete variables as in 2D) with customizable `jitter` (for discrete variables only; default is `0.4`) and `alpha` (default is `1`). In the case of a tile plot the additional argument `text_size` can be used to change the default size of the labels (default is `NULL`). In the case that the *third* variable is discrete one can switch to a facets plot over the third variable by specifying `type = "facets"`. 

**Note 1.5**: In order to change the names on the axes one needs to change the `colnames` of `data`.







## 1.3 Visualizing the Missingness Pattern with Unknown Underlying Values

  * **Functions**: `plot_1D_real_missingness()`, `plot_2D_real_missingness()` and `plot_3D_real_missingness()`.
  * **Target**: Data matrix with missing values whose underlying values are not known.
  * **Purpose**: Visualize the correlation between the missingness pattern of a single column with the values of other columns.

These plot functions are particular useful to get a feeling for sensible assumptions on the missingness pattern when the underlying values are not known. In this case it might be instructive to consider the correlation between the missingness pattern of variable A and the values of variable(s) B/(B,C)/(B,C,D). To this end the functions `plot_1D_real_missingness()`, `plot_2D_real_missingness()` and `plot_3D_real_missingness()` plot the missingness pattern of variable `miss.clm` with respect to the observed values of 1,2 or 3 other variables passed via `data.clm`/`data.clms`, respectively (all three input arguments expect positive integers). As an example we consider the missingness pattern of clarity of our diamonds data `dm_data` and plot it with respect to all other variables:

**Note 1.6**: Rows with missing entries in the data column(s) `data.clm/data.clms` are ignored by `plot_1D_real_missingness()`, `plot_2D_real_missingness()` and `plot_3D_real_missingness()`.

### Example {.tabset}

#### 1D {.tabset}

##### carat

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 1)
```

##### cut

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 2)
```

##### color

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 3)
```

##### depth

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 5)
```

##### table

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 6)
```

##### price

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 7)
```

##### x

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 8)
```

##### y

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 9)
```

##### z

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = 10)
```


#### 2D {.tabset}

##### carat & cut

```{r, echo = TRUE, fig.align = "center"}

plot_2D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(1,2),
                         type = "box" )
```


##### cut & color

```{r, echo = TRUE, fig.align = "center"}

plot_2D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(2,3),
                         type = "facets")
```


##### depth & table 

```{r, echo = TRUE, fig.align = "center"}

plot_2D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(5,6))
```



##### price & x

```{r, echo = TRUE, fig.align = "center"}

plot_2D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(7,8))
```



##### y & z

```{r, echo = TRUE, fig.align = "center"}

plot_2D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(9,10))
```

#### 3D {.tabset}

##### carat & cut & color

```{r, echo = TRUE, fig.align = "center"}

plot_3D_real_missingness(data = dm_data,
                         miss.clm = 4,
                         data.clm = c(1,2,3),
                         type = "facets" )
```


##### depth & table & price

```{r, echo = TRUE, fig.align = "center"}

p = plot_3D_real_missingness(data = dm_data,
                             miss.clm = 4,
                             data.clm = c(5,6,7) )
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_3_dtp.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_3_dtp.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- ###### x & y & z -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->

<!-- p = plot_3D_real_missingness(data = dm_data, -->
<!--                          miss.clm = 4, -->
<!--                          data.clm = c(8,9,10) ) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_3_xyz.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_3_xyz.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

### Description

The default plot in 1D changes its presentation automatically depending on the type of variable passed via `data.clm`: A boxplot is displayed in case of a continuous `data.clm` and a barplot in case of a discrete `data.clm`. Meanwhile, in 2D and 3D the default plot is *always* a scatter plot (where jitter is added to each detected discrete variable), the `alpha` (default is `0.25`) of the data points and the `jitter` (default is `0.4`) of the discrete variables can be customized. For the 2D case one can change to a box- and a facetsplot if one or both variables are discrete, respectively, by passing `type = "box"` or `type = "facets"`, respectively. In the 3D case one can change to a facets plot via `type = "facets"` if the *third* variable is discrete.

### Diamond Data Example {.tabset}

Visualizing the diamonds data with missing entries via `plot_1D_real_missingness` we find that the missingness in `x`, `y` and `z` seems to correlate with the variable `table` and the same seems to be the case between missingness in `carat` and the values of `price` and vice versa, see below. Both of which are signs of non MCAR missingness pattern, hence drawing a different missingness pattern than the default in `data_ImputeBench()` (MCAR) might be appropriate for benchmarking.



#### Miss. Pat. of `x` vs. `table`

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 8,
                         data.clm = 6)
```

#### Miss. Pat. of `y` vs. `table`

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 9,
                         data.clm = 6)
```

#### Miss. Pat. of `z` vs. `table`

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 10,
                         data.clm = 6)
```

#### Miss. Pat. of `carat` vs. `price`

```{r, echo = TRUE, fig.align = "center"}

plot_1D_real_missingness(data = dm_data,
                         miss.clm = 1,
                         data.clm = 7)

```

#### Miss. Pat. of `price` vs. `carat`

```{r, echo = TRUE, fig.align = "center"}
plot_1D_real_missingness(data = dm_data,
                         miss.clm = 7,
                         data.clm = 1)
```



## 1.4 Visualizing the Missingness Pattern with Known Underlying Values

  * **Functions**: `plot_1D_simulated_missingness()`, `plot_2D_simulated_missingness()` and `plot_3D_simulated_missingness()`.
  * **Target**: Data matrix with missing values whose underlying values are known.
  * **Purpose**: Visualize the observed and missingness data distribution.

The family of plot functions `plot_1D_simulated_missingness()`, `plot_2D_simulated_missingness()` and `plot_3D_simulated_missingness()` visualize missingness patterns where the underlying values are known, this can be useful for example if we want to visualize whether the considered simulated missingness pattern drawn by `data_ImputeBench()` or `simulate_ImputeBench()` are reasonable. The columns to be visualized are again passed via the argument `clm` or `clms` for 1D and 2D/3D, respectively. To the end of demonstrating the plot functions we draw a default missingness pattern with the function `simulate_mask()` (as it is called by `data_ImputeBench()` and `simulate_ImputeBench()`), for more details on `simulate_mask()` see Section 2.1.1.

**Note 1.7**: Rows with missing entries in `clm/clms` are discarded by `plot_1D_simulated_missingness()`, `plot_2D_simulated_missingness()` and `plot_3D_simulated_missingness()`. In the example below we use the incomplete diamonds data (`dm_data`) with added additional missingness, hence all incomplete rows in `data` of `clm`/`clms` are discarded. 


```{r, echo = TRUE}
mask.to.visualize = simulate_mask(data = dm_data)
```


### Example {.tabset}

#### 1D {.tabset}

##### carat
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 1)
```

##### cut
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 2)
```

##### color
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 3)
```

##### clarity
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 4)
```

##### price
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 7)
```

##### x
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 8)
```

##### y
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 9)
```

##### z
```{r, echo = TRUE, fig.align = "center"}
plot_1D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clm = 10)
```

#### 2D {.tabset}

##### carat & cut
```{r, echo = TRUE, fig.align = "center"}
plot_2D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clms = c(1,2),
                              type = "box")
```

##### carat & cut
```{r, echo = TRUE, fig.align = "center"}
plot_2D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clms = c(3,4),
                              type = "facets")
```

##### price & x
```{r, echo = TRUE, fig.align = "center"}
plot_2D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clms = c(7,8),
                              alpha = 1)
```

##### y & z
```{r, echo = TRUE, fig.align = "center"}
plot_2D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clms = c(9,10),
                              alpha = 0.1)
```

#### 3D {.tabset}

##### carat & cut & color
```{r, echo = TRUE, fig.align = "center"}
plot_3D_simulated_missingness(data = dm_data,
                              mask = mask.to.visualize,
                              clms = c(1,2,3),
                              type = "facets")
```



<!-- ###### clarity & depth & price -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_simulated_missingness(data = dm_data, -->
<!--                               mask = mask.to.visualize, -->
<!--                               clms = c(4,5,7), -->
<!--                               alpha = 1) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_4_dtp.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_4_dtp.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

##### x & y & z
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_simulated_missingness(data = dm_data,
                                  mask = mask.to.visualize,
                                  clms = c(8,9,10),
                                  alpha = 0.25)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_4_xyz.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_4_xyz.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->



### Description

Following the same principle as `plot_1D_real_missingness()` (and its 2D and 3D counterparts) the missingness pattern is plotted against the values of the data with the difference that the missingness pattern in a variable is plotted against the true underlying values of the same column/variable. The plot choices are however mainly the same as in Section 1.3: The 1D plot chooses automatically a boxplot (continuous) or a barplot (discrete) depending on `clm`. Meanwhile, in 2D the default is always `type = "scatter"`, but one can switch to `type = "box"` (if exactly one variable is discrete) or to `type = "facets"` (if both variables are discrete). Similarly in 3D one can switch from `type = "scatter"` to `type = "facets"` if the *third* variable is discrete. A difference is that in 2D and 3D the color coding is extended to all possible kinds of "missing" (whether missing in one, two or all three variables), this can be suppressed by setting `only.first.entry = TRUE`, see below for the 3D plot of `x`, `y` and `z`, where only missingness in `x` is displayed (always the missingness pattern of the first entry of `clms` is considered in the case of `only.first.entry = TRUE`).


```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_simulated_missingness(data = dm_data,
                                  mask = mask.to.visualize,
                                  clms = c(8,9,10),
                                  alpha = 0.25,
                                  only.first.entry = TRUE)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_4_xyz_ofe.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_4_xyz_ofe.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->



## 1.5 Visualizing the Imputed Values with Unknown Underlying Values

  * **Functions**: `plot_1D_imputed()`, `plot_2D_imputed()` and `plot_3D_imputed()`.
  * **Target**: Data matrix with imputed values whose underlying values are not known.
  * **Purpose**: Compare the distributions of the imputed and the observed values.

The family of plot functions comprised of `plot_1D_imputed()`, `plot_2D_imputed()` and `plot_3D_imputed()` compares the distribution of the imputed data points to the distribution of the observed data points. Hence, this visualization is useful in the case the underlying missing values are unknown and one wants to ensure as a sanity check that the distribution of the imputed values does not differ to much from the original observed data distribution. Again we pass the variables we want to visualize using the argument `clm` or `clms` for 1D and 2D/3D, respectively (expected are positive integers). We continue using the example of the diamonds data, to this end we are computing imputations of `dm_data` (without additional missingness) using the default imputation methods included in `ImputeBench`:

**Additional Exported Functions: Imputation Wrappers.** `ImputeBench` includes four default imputation methods and a baseline imputation method for which wrapper functions are exported. All wrapper functions take the same two input arguments: `data` for the data matrix to be imputed and `args` for a list of specified arguments (each list differs respective of the imputation method used). The five wrapper functions are:

  * `baseline_imputation()` comprises the mean and median imputation. Its argument list specified via `args` is given by a single entry `method` that expects a character string (supported are `"mean"` and `"median"`).
  * `wknn()` (k-nearest neighbour imputation) is wrapping the corresponding function(s) in the `VIM` package. Its argument list specified via `args` is given by a single entry `k` expecting a positive integer (as a default method `wknn()` uses `train_knn()` - see further below - to train `k` via a bisection algorithm).
  * `wMICE()` (Multiple Imputations by Chained Equations) is wrapping the corresponding function(s) in the `mice` package. Its argument list specified via `args` is given by the three entries `mincor` (either `NULL` or a numeric between $0$ and $1$), `m` (a positive integer) and `maxit` (a positive integer) (as a default method `wMICE()` uses the values `mincor = 0.1`, `m = 5` and `maxit = 5`).
  *  `wmissF()` (missForest) is wrapping the corresponding function(s) in the `missForest` package. Its argument list specified via `args` is given by a single entry `ntree` (as a default method `wmissF()` uses the value `ntree = 100`).
  * `wsImpute()` (soft impute) wrappes the corresponding function(s) in the `softImpute` package. Its argument list specified via `args` is given by the three entries `rank.max` (a positive integer), `lambda` (a positive numeric) and `type` (a string, either `"svd"`, or, `"als"`, see the soft impute vignette for details) (as a default method `wsImpute()` uses `train_sImpute()` - see further below - to train `lambda` via an bisection algorithm, set `rank.max` to the minimium of column and row count of `data` and sets `type = "svd"`).
  
**Additional Exported Functions: Rounding Imputation Results.** The function `round_imputation()` is exported by `ImputeBench` as not all (default) imputation methods round and/or binarize their results appropriately. The function has two arguments, the first being `data` to pass the data set (possibly with missing entries) and second being `imputed_data` to pass the imputed data set. The function first checks each column of `data` if it only consists only of positive integers and/or of only values in $\{0,1\}$. Note, this is done in a data-driven way and can result into categorization of columns as for example binary because only values in $\{0,1\}$ are observed, eventhough other values are allowed. `round_imputation()` goes on to round all columns where only positive integers are detected to their nearest integer and take the entry-wise minimum with $0$. Last, for all detected binary columns the entry-wise maximum with $1$ is taken.



**Additional Exported Functions: Parameter Training.** For the two wrapper functions `wknn()` and `wsImpute()` two training functions `train_knn()` and `train_sImpute()` are exported by `ImputeBench()`. Both have one input argument `data` which expects a numerical data matrix with missing entries (encoded as `NA`) and output the respective list of arguments `args` for `wknn()` or `wsImpute()`, respectively. For the three other imputation methods no training functions are supplied by `ImputeBench` due to no trainable parameter (`baseline_imputation()`), method being designed to work well on default values (`wmissF()`) or too complex modelling needed that it would go beyond the scope of `ImputeBench` (`wMICE()`).

**Note 1.8**: In both benchmarking functions `data_ImputeBench()` and `simulation_ImputeBench()` MICE and missForest use set default values (for details see above).


```{r, echo = TRUE, messages = FALSE, warnings = FALSE, results = 'hide'}

args.knn.full = train_KNN(data = dm_data)
args.softimpute.full = train_sImpute(data = dm_data)

imp.knn.full = wKNN(data = dm_data,
                    args = args.knn.full)
imp.mice.full = wMICE(data = dm_data,
                      args = list(mincor = 0.5,
                                  m = 5, # m = 5 is the standard default of MICE
                                  maxit = 5)) # maxit = 5 is the standard default in MICE
imp.soft.full = wsImpute(data = dm_data,
                         args = args.softimpute.full)
imp.missF.full = wmissF(data = dm_data,
                        args = list(ntree = 100)) # ntree = 100 is the standard default of missForest
imp.median.full = baseline_imputation(data = dm_data,
                                      args = list(method = "median"))

# For all ensure that columns 2,3 and 4 are discrete (integrated in data_ImputeBench() but not in wKNN, ... , wmissF, baseline_imputation)
imp.knn.full[, c(2,3,4)] = base::pmax(round(imp.knn.full[ , c(2,3,4)]), 0 )
imp.mice.full[, c(2,3,4)] = base::pmax(round(imp.mice.full[ , c(2,3,4)]), 0 )
imp.soft.full[, c(2,3,4)] = base::pmax(round(imp.soft.full[ , c(2,3,4)]), 0 )
imp.missF.full[, c(2,3,4)] = base::pmax(round(imp.missF.full[ , c(2,3,4)]), 0 )
imp.median.full[, c(2,3,4)] = base::pmax(round(imp.median.full[ , c(2,3,4)]), 0 )


```

Now we compare the observed and the imputed values of the diamond data:

### Example {.tabset}

#### 1D {.tabset}

##### carat {.tabset}

###### median imputation

```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 1,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 1,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 1,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 1,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 1,
                binwidth = 0.01)
```

##### cut {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 2,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 2,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 2,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 2,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 2,
                binwidth = 0.01)
```

##### color  {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 2,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 3,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 3,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 3,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 3,
                binwidth = 0.01)
```

##### clarity {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 4,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 4,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 4,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 4,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 4,
                binwidth = 0.01)
```

##### price {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 7,
                binwidth = 0.1)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 7,
                binwidth = 0.1)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 7,
                binwidth = 0.1)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 7,
                binwidth = 0.1)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 7,
                binwidth = 0.1)
```

##### x {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 8,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 8,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 8,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 8,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 8,
                binwidth = 0.01)
```

##### y {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 9,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 9,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 9,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 9,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 9,
                binwidth = 0.01)
```

##### z {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clm = 10,
                binwidth = 0.01)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clm = 10,
                binwidth = 0.01)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clm = 10,
                binwidth = 0.01)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clm = 10,
                binwidth = 0.01)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clm = 10,
                binwidth = 0.01)
```

#### 2D {.tabset}

##### carat & cut {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clms = c(1,2),
                jitter = 0.3)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clms = c(1,2),
                jitter = 0.3)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clms = c(1,2),
                jitter = 0.3)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clms = c(1,2),
                jitter = 0.3)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clms = c(1,2),
                jitter = 0.3)
```

##### color & clarity {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clms = c(3,4),
                jitter = 0.3)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clms = c(3,4),
                jitter = 0.3)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clms = c(3,4),
                jitter = 0.3)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clms = c(3,4),
                jitter = 0.3)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clms = c(3,4),
                jitter = 0.3)
```


##### price & x {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clms = c(7,8),
                jitter = 0.3)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clms = c(7,8),
                jitter = 0.3)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clms = c(7,8),
                jitter = 0.3)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clms = c(7,8),
                jitter = 0.3)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clms = c(7,8),
                jitter = 0.3)
```


##### y & z {.tabset}

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.median.full,
                clms = c(9,10),
                jitter = 0.3)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.knn.full,
                clms = c(9,10),
                jitter = 0.3)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.mice.full,
                clms = c(9,10),
                jitter = 0.3)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.missF.full,
                clms = c(9,10),
                jitter = 0.3)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed(data = dm_data,
                imputed_data = imp.soft.full,
                clms = c(9,10),
                jitter = 0.3)
```

#### 3D {.tabset}

##### carat & cut & color {.tabset}

<!-- **median imputation** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.median.full, -->
<!--                 clms = c(1,2,3), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_ccc_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_ccc_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.knn.full, -->
<!--                 clms = c(1,2,3), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_ccc_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_ccc_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

###### MICE
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed(data = dm_data,
                    imputed_data = imp.mice.full,
                    clms = c(1,2,3),
                    jitter = 0.3)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_6_ccc_3.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_6_ccc_3.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- **missForest** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.missF.full, -->
<!--                 clms = c(1,2,3), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_ccc_4.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_ccc_4.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **soft impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.soft.full, -->
<!--                 clms = c(1,2,3), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_ccc_5.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_ccc_5.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

##### clarity & depth & price {.tabset}

<!-- **median imputation** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.median.full, -->
<!--                 clms = c(4,5,7), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_cdp_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_cdp_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.knn.full, -->
<!--                 clms = c(4,5,7), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_cdp_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_cdp_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **MICE** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.mice.full, -->
<!--                 clms = c(4,5,7), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_cdp_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_cdp_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **missForest** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.missF.full, -->
<!--                 clms = c(4,5,7), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_cdp_4.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_cdp_4.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed(data = dm_data,
                    imputed_data = imp.soft.full,
                    clms = c(4,5,7),
                    jitter = 0.3)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_6_cdp_5.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_6_cdp_5.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

##### x & y & z {.tabset}

<!-- **median imputation** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.median.full, -->
<!--                 clms = c(8,9,10), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_xyz_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_xyz_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.knn.full, -->
<!--                 clms = c(8,9,10), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_xyz_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_xyz_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **MICE** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.mice.full, -->
<!--                 clms = c(8,9,10), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_xyz_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_xyz_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

###### missForest
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed(data = dm_data,
                    imputed_data = imp.missF.full,
                    clms = c(8,9,10),
                    jitter = 0.3)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_6_xyz_4.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_6_xyz_4.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- **soft impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed(data = dm_data, -->
<!--                 imputed_data = imp.soft.full, -->
<!--                 clms = c(8,9,10), -->
<!--                 jitter = 0.3) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_6_xyz_5.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_6_xyz_5.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


### Description

The 1D plots created show histogram comparisons of the observed values and the imputed values, the `binwidth` (default is `nrow(data)/30`) can be chosen manually if necessary. All 2D and 3D plots are scatter plots where the transparency of the complete data points can be changed by the argument `alpha` (default is `0.25`) and whose jitter (automatically added to discrete variables) can be changed via the argument `jitter` (default is `0.4`).



## 1.6 Visualizing the Imputed Values with Known Underlying Values

  * **Functions**: `plot_1D_imputed_sim()`, `plot_2D_imputed_sim()` and `plot_3D_imputed_sim()`.
  * **Target**: Data matrix with imputed values whose underlying values are known.
  * **Purpose**: Visualize observed, missing and imputed data distributions.

In this subsection we discuss visualizing the imputed values (or the imputation performance) in the case the actual missing values are known via the functions `plot_1D_imputed_sim()`, `plot_2D_imputed_sim()` and `plot_3D_imputed_sim()`. This visualization might be useful to sanity check the benchmarking results, i.e. visual expection on the masked data entries and their imputed values. As and example let us consider the results of a default benchmarking of imputation methods on the diamonds data by `data_ImputeBench()`, for details see Section 2. We reuse the missingness pattern `mask.to.visualize` of Section 1.4 as it is drawn with such default values - again, details follow in Section 2 - and we construct five imputed data sets with the default functions (and training functions), recall their description in Section 1.5. 


```{r, echo = TRUE, message = FALSE, warnings = FALSE, results = 'hide'}

data.with.extra.missingness = add_missing(data = dm_data,
                                          mask = mask.to.visualize)

args.knn = train_KNN(data = data.with.extra.missingness)
args.softimpute = train_sImpute(data = data.with.extra.missingness)

imp.knn = wKNN(data = data.with.extra.missingness,
               args = args.knn)
imp.mice = wMICE(data = data.with.extra.missingness,
                 args = list(mincor = 0.5,
                             m = 5,
                             maxit = 5))
imp.soft = wsImpute(data = data.with.extra.missingness,
                    args = args.softimpute)
imp.missF = wmissF(data = data.with.extra.missingness,
                   args = list(ntree = 100))
imp.median = baseline_imputation(data = data.with.extra.missingness,
                                 args = list(method = "median"))

# For all ensure that columns 2,3 and 4 are discrete
imp.knn[, c(2,3,4)] = base::pmax(round(imp.knn[ , c(2,3,4)]), 0 )
imp.mice[, c(2,3,4)] = base::pmax(round(imp.mice[ , c(2,3,4)]), 0 )
imp.soft[, c(2,3,4)] = base::pmax(round(imp.soft[ , c(2,3,4)]), 0 )
imp.missF[, c(2,3,4)] = base::pmax(round(imp.missF[ , c(2,3,4)]), 0 )
imp.median[, c(2,3,4)] = base::pmax(round(imp.median[ , c(2,3,4)]), 0 )
```


We now plot the imputed values versus the actual underlying values, as always the column(s) are chosen via the argument `clm` or `clms` for 1D or 2D/3D, respectively (expected are positive integers).

**Note 1.9**: Rows with missing values in `clm`/`clms` of `data` are ignored by `plot_1D_imputed_sim()`, `plot_2D_imputed_sim()` and `plot_3D_imputed_sim()`. As we now compare imputation performance of a data set with missing entries of some we know the underlying values (additional mask) and of some we do not know the underlying values, all rows with "real" missing entries in `clm`/`clms` are discarded in the following plots.

### Example {.tabset}

#### 1D {.tabset}

##### carat {.tabset}

###### median imputation

```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 1)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 1)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 1)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 1)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 1)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.4,
                    clm = 1)
```


##### cut {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 2)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 2)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 2)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 2)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 2)
```

###### All in one Plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.7,
                    clm = 2)
```

##### color {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 3)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 3)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 3)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 3)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 3)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.4,
                    clm = 3)
```

##### clarity {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 4)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 4)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 4)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 4)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 4)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.3,
                    clm = 4)
```

##### price {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 7)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 7)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 7)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 7)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 7)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.25,
                    clm = 7)
```

##### x {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 8)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 8)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 8)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 8)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 8)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.5,
                    clm = 8)
```

##### y {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 9)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 9)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 9)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 9)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 9)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.5,
                    clm = 9)
```

##### z {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clm = 10)
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    clm = 10)
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    clm = 10)
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    clm = 10)
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    clm = 10)
```

###### all in one plot
```{r, echo = TRUE, fig.align = "center"}
plot_1D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    additional.imputations = list( imp.knn,
                                                   imp.soft,
                                                   imp.missF,
                                                   imp.mice),
                    imp.names = c("median", "knn", "soft", "missF", "MICE"),
                    jitter = 0.3,
                    alpha = 0.5,
                    clm = 10)
```

#### 2D {.tabset}

##### carat & cut {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    alpha_line = 0.5,
                    jitter = 0.2,
                    clms = c(1,2))
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.5,
                    jitter = 0.2,
                    imputed_data = imp.knn,
                    clms = c(1,2))
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    alpha_line = 0.5,
                    mask = mask.to.visualize,
                    jitter = 0.2,
                    imputed_data = imp.mice,
                    clms = c(1,2))
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    alpha_line = 0.5,
                    jitter = 0.2,
                    clms = c(1,2))
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    alpha_line = 0.5,
                    jitter = 0.2,
                    clms = c(1,2))
```

##### color & clarity {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.median,
                    clms = c(3,4),
                    type = "tile")
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    type = "tile",
                    clms = c(3,4))
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    type = "tile",
                    imputed_data = imp.mice,
                    clms = c(3,4))
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.missF,
                    type = "tile",
                    clms = c(3,4))
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    type = "tile",
                    clms = c(3,4))
```

##### price & x {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.median,
                    clms = c(7,8))
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.knn,
                    alpha_line = 0.35,
                    clms = c(7,8))
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.mice,
                    alpha_line = 0.35,
                    clms = c(7,8))
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.missF,
                    clms = c(7,8))
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    imputed_data = imp.soft,
                    alpha_line = 0.35,
                    clms = c(7,8))
```

##### y & z {.tabset} 

###### median imputation
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.median,
                    clms = c(9,10))
```

###### knn impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.knn,
                    clms = c(9,10))
```

###### MICE
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.mice,
                    clms = c(9,10))
```

###### missForest
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.missF,
                    clms = c(9,10))
```

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
plot_2D_imputed_sim(data = dm_data,
                    mask = mask.to.visualize,
                    alpha_line = 0.35,
                    imputed_data = imp.soft,
                    clms = c(9,10))
```

#### 3D {.tabset}

##### carat & cut & color {.tabset} 

<!-- **median imputation** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     imputed_data = imp.median, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     clms = c(1,2,3)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_ccc_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_ccc_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     imputed_data = imp.knn, -->
<!--                     clms = c(1,2,3)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_ccc_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_ccc_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

###### MICE
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed_sim(data = dm_data,
                        mask = mask.to.visualize,
                        alpha_line = 0.5,
                        jitter = 0.3,
                        imputed_data = imp.mice,
                        clms = c(1,2,3))
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_5_ccc_3.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_5_ccc_3.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- **missForest** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     imputed_data = imp.missF, -->
<!--                     clms = c(1,2,3)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_5_ccc_4.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_5_ccc_4.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- **soft impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     imputed_data = imp.soft, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     clms = c(1,2,3)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_ccc_5.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_ccc_5.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


##### clarity & depth & price {.tabset}

<!-- **median imputation** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     imputed_data = imp.median, -->
<!--                     jitter = 0.3, -->
<!--                     clms = c(4,5,7)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_cdp_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_cdp_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     mask = mask.to.visualize, -->
<!--                     imputed_data = imp.knn, -->
<!--                     clms = c(4,5,7)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_cdp_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_cdp_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

<!-- **MICE** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     jitter = 0.3, -->
<!--                     alpha_line = 0.5, -->
<!--                     imputed_data = imp.mice, -->
<!--                     clms = c(4,5,7)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_cdp_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_cdp_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

###### missForest
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed_sim(data = dm_data,
                        mask = mask.to.visualize,
                        alpha_line = 0.5,
                        jitter = 0.3,
                        imputed_data = imp.missF,
                        clms = c(4,5,7))
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_5_cdp_4.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_5_cdp_4.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

###### soft impute
```{r, echo = TRUE, fig.align = "center"}
p = plot_3D_imputed_sim(data = dm_data,
                        mask = mask.to.visualize,
                        alpha_line = 0.5,
                        jitter = 0.3,
                        imputed_data = imp.soft,
                        clms = c(4,5,7))
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_5_cdp_5.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_5_cdp_5.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

<!-- ##### x & y & z {.tabset} -->

<!-- ###### median imputation -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                         mask = mask.to.visualize, -->
<!--                         alpha_line = 0.5, -->
<!--                         imputed_data = imp.median, -->
<!--                         jitter = 0.3, -->
<!--                         clms = c(8,9,10)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "p_5_xyz_1.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "p_5_xyz_1.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->



<!-- **knn impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     jitter = 0.3, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     imputed_data = imp.knn, -->
<!--                     clms = c(8,9,10)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_xyz_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_xyz_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


<!-- **MICE** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     imputed_data = imp.mice, -->
<!--                     clms = c(8,9,10)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_xyz_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_xyz_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


<!-- **missForest** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     alpha_line = 0.5, -->
<!--                     jitter = 0.3, -->
<!--                     imputed_data = imp.missF, -->
<!--                     clms = c(8,9,10)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_xyz_4.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_xyz_4.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->


<!-- **soft impute** -->
<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- p = plot_3D_imputed_sim(data = dm_data, -->
<!--                     mask = mask.to.visualize, -->
<!--                     jitter = 0.3, -->
<!--                     alpha_line = 0.5, -->
<!--                     imputed_data = imp.soft, -->
<!--                     clms = c(8,9,10)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_5_xyz_5.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_5_xyz_5.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->

<!-- ``` -->

### Description

`plot_1D_imputed_sim()` produces a scatter plot (or tile plot in the case of discrete variables) of imputed versus ground truth values. This can be extended to display multiple imputations on the same variable by the use of the argument `additional.imputations`. The `additional.imputations` argument expects as an input a list of imputed data matrices, be aware that you still need to supply an imputed matrix via the `imputed_data` argument. To rename the entries of the color legend you can add names as a vector of character strings passed to `imp.names` (The first entry corresponds to `imputed_data` while the following entries correspond to the imputed data matrices of the list `additional.imputations` in the exact order they are listed). In the case multiple imputed matrices of different methods are supplied the output plot is always a scatter plot (with jitter added if the variable is discrete). As for all of the functions of the example one can pass the arguments `alpha` (default is `1`) and `jitter` (default is `0.4`) to change the transparency and jitter of the scatter points. 


In 2D and 3D only one imputed matrix can be visualized at a time, the output plot is a scatter plot showing the complete data points, the missing ones and the imputed ones. Each missing data point is connected via a dashed line to its imputed counterpart, the transparency of the line can be controlled with the argument `alpha_line` (default is `1`). Additionally via the `alpha` argument (default is `0.25`) the transparency of the complete data points can be controlled (the transparency of the missing and imputed data points can not be controlled). Moreover, as usual for discrete variables `jitter` (default is `0.4`) controls the added jitter. Note, that in these plots the label "missing" makes no distinction between how many and/or which entry/entries is/are missing, as this that can often be read of the connecting lines being usually parallel to the axis if a data coordinate was not missing (in the case of no jitter). Last, for two discrete variables in 2D via passing `type = "tile"` one can choose to display a tile plot comparing the ground truth data distribution of the missing entries on the two discrete variables with the imputed one, color coded is its relative change (additionally the bin counts are compared: Written in red the imputed values, written in black the missing values). In the case of a tile plot the additional argument `text_size` can be used to change the default size of the labels (default is `NULL`).












# 2 Benchmarking on Real Data - `data_ImputeBench()`

In this section we discuss the function `data_ImputeBench()` and its arguments. This function is benchmarking imputation methods on (real) dm_data, possibly with missing entries. It can be used as a tool to find the most appropriate imputation method for user provided data with missing entries. To the end of showcasing `data_ImputeBench()` we will use the data set `dm_data` constructed in Section 1 from the `diamonds` data set of `ggplot2`. Recall that we have shrunk the number of rows to a feasible size, made all entries numeric and added some missing entries whose values are considered unknown in the following. 

Let us start by running `data_ImputeBench` with default arguments and `data = dm_data`:

```{r, echo = TRUE, fig.align = "center"}
Simulation.Results = data_ImputeBench(data = dm_data,
                                      repetitions = reps,
                                      verbose = TRUE)
```


The output of `data_ImputeBench()` is a list with two entries. The first entry is `$evalutation`, which we can plot via the function `plot_ImputeBench()` (details on customizing `plot_ImputeBench()` will be given in Section 2.5 and 3.5):

```{r, echo = TRUE, fig.align = "center"}
plot_ImputeBench(Simulation.Results$evaluation,
                 title = "Imputation Performance",
                 error_type = "overall")
```

The second entry `$data.list` stores additional data as a list:

  * The first list entry is named `$Overview_Scenarios` and includes all scenarios used to draw additional missingness patterns. This includes all default scenarios or any randomly drawn scenarios (in the case only `missingness_parameters` are provided as explained in Section 2.1.2).
  * The remaining entries are named by their respective scenario(s) (see Section 2.1 for details). Each of them are themselves lists indexed by the run number (from 1 to the number of repetitions, see Section 2.4 for details). Each list entry (e.g. `Simulation.Results$data.list$Scenario_1[[1]]`) is again itself a list consisting of
    * `$ID` its scenario and run number.
    * `$mask` the drawn missingness pattern as a numeric matrix. 
    * `$args` a list of arguments (trained or chosen) of the respective imputation methods compared. 
    
In our case we find under `$mask` missingness patterns drawn under default values for the missingness pattern simulation protocol reflecting the assumption of MCAR on all columns that have missing entries in the first place and with the amount of missingness guided by the real amount of missing entries in `dm_data`. 

**Note 2.1**: When large and numerous additional missingness patterns are simulated one can suppress the collection of the additional data gathered in `$data.list` entry by passing the argument `output_data = FALSE` to `data_ImputeBench()` (cf. Section 2.4).

```{r, echo = TRUE}
head(Simulation.Results$data.list$`Default Scenario`[[1]]$mask)
Simulation.Results$data.list$`Default Scenario`[[1]]$args
```


Let us give a short overview of the remainder of the section consisting of detailing the different arguments that can be passed to `data_ImputeBench()`:

  * **Section 2.1:** A guide on how to customize the draw of the missingness pattern in `data_ImputeBench()` by specifying different `scenarios` (*Section 2.1.1*) or by specifying `missingness_parameters` which in turn are used to draw `scenarios` (*Section 2.1.2*).
  * **Section 2.2:** A guide on how to customize the compared imputation methods in `data_ImputeBench()`:
  
    * *Section 2.2.1:* Adding imputation methods via the argument `methods`.
    * *Section 2.2.2:* Adding training function(s) for the paraemters of the added imputation methods via the argument `training`.
    * *Section 2.2.3:* Removing imputation methods from the default methods via the argument `default_methods`.
    * *Section 2.2.4:* Changing how often parameters of imputation methods are retrained via the argument `retrain_always`. 
    * *Section 2.2.5:* Choosing the `baseline_method`.
    
  * **Section 2.3:** A guide on further customizing the protocol of benchmarking imputation methods: `error_measure` and `scaling_robust` (*Section 2.3.1*), `error_grouping` (*Section 2.3.2*) and `repetitions` (*Section 2.3.3*).
  * **Section 2.4:** A guide on technical arguments of `data_ImputeBench()`: `verbose`, `seed`, `max_time` and `output_data`.
  * **Section 2.5:** A guide on `plot_ImputeBench()` for benchmarking on real data.
  * **Section 2.6:** A guide on how to extract sample missingness pattern from the benchmarking using `example_ImputeBench()`.


## 2.1 Changing the Missingness Pattern Simulation

### 2.1.1 By specifying `scenarios`

To specify your own missingness scenario (for the definition of a missingness scenario see RMTBM22) `data_ImputeBench()` provides the argument `scenarios` which is by default `NULL` prompting `data_ImputeBench()` to draw a scenario from missingness parameters or use the default scenario which tries to recreate the missingness structure present in the data by assuming for each variable MCAR, details on both options follow below. Note first, that the parameter `scenarios` expects a list of scenarios. Each `scenarios` entry is then itself a list which may include entries for `MCAR`, `MAR` and/or `MNAR` missingness, who are again themselves lists with parameter choices that are explained in detail via the following example. Consider the diamonds example, we define a list of three scenarios inspired by our observations on the correlations between missingness pattern and data made in Section 1.3:

```{r, echo = TRUE}

scenarios = list("MCAR + MNAR" = list("MCAR" = list(columns = c(2:4),
                                                    probability = rep(0.2, times = 3)),
                                      "MNAR" = list(columns = c(1,7:10),
                                                    probability.upper = rep(0.8, times = 5),
                                                    probability.lower = rep(0.2, times = 5),
                                                    probability.midpoint = list(c(0.8,0.25),
                                                                                c(0.8,0.25),
                                                                                c(0.8,0.25),
                                                                                c(0.8,0.25),
                                                                                c(0.8,0.25))
                                                    )
                                      ),
                 "MCAR + MAR" = list("MCAR"  = list(columns = c(2:4),
                                                    probability = rep(0.2, times = 3)),
                                     "MAR" = list(columns = c(1,7:10),
                                                  reg.columns = list(c(7),
                                                                     c(1),
                                                                     c(6),
                                                                     c(6),
                                                                     c(6)),
                                                  probability.upper = rep(0.8, times = 5),
                                                  probability.lower = rep(0.1, times = 5),
                                                  probability.midpoint = list(c(0.6,0.3),
                                                                              c(0.6,0.3),
                                                                              c(0.6,0.3),
                                                                              c(0.6,0.3),
                                                                              c(0.6,0.3))
                                                    )
                                        ),
                 "MCAR + MAR + MNAR" = list("MCAR" = list(columns = c(2:4),
                                                          probability = rep(0.33, times = 3)),
                                            "MAR" = list(columns = c(8:10),
                                                         reg.columns = list(c(6),
                                                                            c(6),
                                                                            c(6)),
                                                         probability.upper = rep(0.8, times = 3),
                                                         probability.lower = rep(0.1, times = 3),
                                                         probability.midpoint = list(c(0.6,0.3),
                                                                                     c(0.6,0.3),
                                                                                     c(0.6,0.3))),
                                            "MNAR" = list(columns = c(1,7),
                                                          probability.upper = c(0.8,0.8),
                                                          probability.lower = c(0.2,0.2),
                                                          probability.midpoint = list(c(0.8,0.25),
                                                                                      c(0.8,0.25))
                                                          )
                                              )
              )

```


How to specify **MCAR**: Add a list in which you can specify the following arguments:

  * `columns`: Add the column numbers that should be masked MCAR. A vector with integer entries is expected.
  * `probability`: Add the probability with which the MCAR columns should be masked. A vector of equal length as `columns` is expected with entries between 0 and 1.

If only one of the parameters are provided, the other one is drawn/set by default as:

  * `columns`: Half of the columns of the `data` are picked at random.
  * `probability`: Set to `0.25`.

How to specify **MAR**: Add a list in which you can specify the following arguments:

  * `columns`: Add the column numbers that should be masked MAR. A vector with integer entries is expected
  * `reg.columns`: Add a list of length equal to the number of MAR `columns`. Each list entry specifies via a vector with integer entries the column numbers which should be correlated with the missingness pattern of the corresponding MAR missing column.
  * `probability.upper`, `probability.lower` and `probability.midpoint`: These three parameters define the (piecewise) sigmoid function that is used to convert the values of the regressor columns into missingness probabilities for the respective MAR column. Details are given below. Expected are for the first two entries vectors of length equal to `columns` with entries in (0,1), in particular not equal to 0 or 1. For the parameter `probability.midpoint` a list of length equal to `columns` is expected, each entry being a vector of length 2 with entries in (0,1).

If any one of the parameters are provided, parameters that are missing are drawn/set by default as:

  * `columns`: Half of the columns are sampled.
  * `reg.columns`: For each column in `columns` a number $k$ is drawn uniform at random from $\lbrace{}1,2,3\rbrace$, then $k$ columns are drawn uniformly at random from the set of all columns without the column in question and denoted in the list of `reg.columns`.
  * `probability.upper`: Set to `0.8` for each entry in `columns`.
  * `probability.lower`: Set to `0.2` for each entry in `columns`.
  * `probability.midpoint`: Set to `c(0.5,0.5)` for each entry in `columns`.

How to specify **MNAR**: Add a list in which you can specify the following arguments:

  * `columns`: Add the column numbers that should be masked MNAR. A vector with integer entries is expected
  * `probability.upper`, `probability.lower` and `probability.midpoint`: These three parameters define the (piecewise) sigmoid function that is used to convert the values of the respective column into missingness probabilities for itself. Details are given below. Expected are for the first two entries a vector of length equal to `columns` with entries in (0,1), in particular not equal to 0 or 1. For the parameter `probability.midpoint` a list of length equal to `columns` is expected, each entry being a vector of length 2 with entries in (0,1).

If any one of the parameters are provided, parameters that are missing are drawn/set by default as:

  * `columns`: Half of the columns are sampled.
  * `probability.upper`: Set to `0.8` for each entry in `columns`.
  * `probability.lower`: Set to `0.2` for each entry in `columns`.
  * `probability.midpoint`: Set to `c(0.5,0.5)` for each entry in `columns`.

In the case that `scenarios = NULL` the scenarios are drawn with respect to `missingness_parameters`, see Section 1.2.2 below. In the case that also `missingness_parameters = NULL` and `data` contains missing entries `scenarios` are set as below:
```{r, echo = TRUE, eval = FALSE}
clms.with.miss = which(exists.miss != 0)
how.much.miss = exists.miss[clms.with.miss]/nrow(dm_data)
scenarios = list("Default Scenario" = list(MCAR = list( columns =  clms.with.miss,
                                                  probability = how.much.miss)))
```

In the case that `missingness_parameters = NULL` but `data` does not contain missing entries, they are drawn by the default missingness parameters, see Section 2.2.2.


**Additional Exported Function**: `data_ImputeBench()` calls internally the function `simulate_mask()` which is exported and can be used to simulate missingness patterns from a missingness scenario. The inputs of `simulate_mask()` are `scenario` - which expects in contrast to its counterpart in `data_ImputeBench()` only **one** scenario (opposed to a list of scenarios) in the form as described above - `data` - which expects a numeric matrix with possibly missing entries - and `seed`. 


**Definition of the Sigmoid Function**: The impact of the parameters `probability.lower`, `probability.upper` and `probability.midpoint` that can be specified for MAR and MNAR columns is explained in the following. In short they define a piece-wise sigmoid function that translates data values to their probabilities of being missing. In the following, let $p_0$ denote `probability.lower`, $p_1$ denote the second entry of `probability.midpoint` and $p_2$ denote `probability.upper` (by abuse of notation we consider a single entry of the respective parameters). When simulating a mask by `simulate_mask()` for a biven column that should be masked, first, the observed minimum and maximum of said column will be computed and denoted by $x_0$ and $x_2$, respectively. Furthermore let $\tilde{x}$ be the first entry of `probability_midpoint` then we compute $x_1:=\tilde{x}(x_2-x_0)+x_0$. Consider the general sigmoid function given by $$f_{b,\alpha}(x)=\frac{1}{1+\exp{}(-bx+\alpha)}$$ and note that its parameters $b$ and $\alpha$ are uniquely determined by specifying two points on its graph. The function translating values into probabilities of being missing is given by using for all values less than $x_1$ the sigmoid function uniquely determined by $f_{b,\alpha}(x_0)=p_0$ and $f_{b,\alpha}(x_1)=p_1$ and for all values larger or equal $x_1$ the sigmoid function uniquely determined by $f_{b,\alpha}(x_1)=p_1$ and $f_{b,\alpha}(x_2)=p_2$. 

**Additional Exported Function**: To have an idea how the piecewise sigmoid function described above looks like `ImputeBench` includes the function `plot_sigmoid()` plotting the piecewise sigmoid function described above with $x_0=-1$ and $x_2=1$, see the example that follows. Its arguments are `probability.lower`, `probability.upper` and `probability.midpoint`.

**Remark on Multiple Regressor Columns** In the MAR case where multiple columns are used as regressors, all columns are standardized and added together before passing through the piecewise-sigmoid (Hence each column will have an equal weight in the regression). The reason for this choice is to keep the amount of parameters manageable. 

**Note 2.2**: To have column A be masked positively influenced by column B and negatively influenced by column C one needs to multiply beforehand column C in the `data` by $-1$ and specify a MAR column on A regressed on B and C with high `probability.upper` and low `probability.lower`.

#### Example - Piecewise Sigmoid Function {.tabset}

##### $p_0=0.1,p_1=0.3,p_2=0.8,\tilde{x}=0.6$

```{r, echo = TRUE, fig.align = "center"}

plot_sigmoid(probability.upper = 0.8,
             probability.lower = 0.1,
             probability.midpoint = c(0.6,0.3))

```

##### $p_0=0.2,p_1=0.25,p_2=0.8,\tilde{x}=0.8$

```{r, echo = TRUE, fig.align = "center"}
plot_sigmoid(probability.upper = 0.8,
             probability.lower = 0.2,
             probability.midpoint = c(0.8,0.25))
```

##### $p_0=0.9,p_1=0.78,p_2=0.05,\tilde{x}=0.3$

```{r, echo = TRUE, fig.align = "center"}
plot_sigmoid(probability.upper = 0.05,
             probability.lower = 0.9,
             probability.midpoint = c(0.3,0.78))

```

#### Example - Run of `data_ImputeBench()` with Customized Scenarios {.tabset}

Now let us run again `data_ImputeBench()` with the new scenario choices:

```{r, echo = TRUE, fig.align = "center"}

Results.2 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios)

plot_ImputeBench(Evaluation = Results.2$evaluation)

```

Let us look at the drawn missingness patterns for some MAR and MNAR columns using the `$data.list` output:

##### carat & price {.tabset}

###### Scenario 1 - MNAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MNAR`[[1]]$mask,
                              clms = c(1,7),
                              alpha = 0.7)

```

###### Scenario 2 - MAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MAR`[[1]]$mask,
                              clms = c(1,7),
                              alpha = 0.7)

```

###### Scenario 3 - MNAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MAR + MNAR`[[1]]$mask,
                              clms = c(1,7),
                              alpha = 0.7)

```


##### x & y {.tabset}

###### Scenario 1 - MNAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MNAR`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)

```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_news_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_news_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

###### Scenario 2 - MAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MAR`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)

```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_news_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_news_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

###### Scenario 3 - MAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.2$data.list$`MCAR + MAR + MNAR`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)

``` 

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_news_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_news_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->


### 2.1.2 By Specifying `missingness_parameters`

In the case one does not want to specify missingness scenarios, for example if imputation methods should be benchmarked on a real data set that does not observe missing entries, one can leave `scenarios = NULL` and pass only the argument `missingness_parameters` to `data_ImputeBench()`, for details on how missingness scenarios are drawn from missingness parameters see RMTBM22 (Note that in the case of benchmarking on simulated data by `simulation_ImputeBench` discussed in Section 3 only `missingness_parameters` can be passed).  Let us consider to this end the full diamond matrix `diamonds.mtrx` and specify some `missingness_parameters`. The format is the same as in `scenarios` just that the arguments of the MCAR, MAR and MNAR lists differ slightly, details are given again further below using the following example.

```{r, echo = TRUE, fig.align = "center"}
missingness_parameters = list("Parameters 1" = list("MCAR" = list(columns = 1:10,
                                                                  size = 10,
                                                                  probability = 0.25)
                                                    ),
                              "Parameters 2" = list("MCAR" = list(columns = 1:10,
                                                                  size = 10,
                                                                  probability = 0.05),
                                                    "MAR" = list(columns = 2:4,
                                                                 size = 3,
                                                                 size.regressors = c(1,2),
                                                                 probability.upper = 0.9,
                                                                 probability.lower = 0.1,
                                                                 probability.midpoint = c(0.5,0.2)),
                                                    "MNAR" = list(columns = c(5,10),
                                                                  size = 2,
                                                                  probability.upper = 0.05,
                                                                  probability.lower = 0.95,
                                                                  probability.midpoint = c(0.5,0.3))
                                                    ),
                              "Parameters 3 " = list("MAR" = list(columns = 6:10,
                                                                  size = 5,
                                                                  size.regressors = c(1,2),
                                                                  probability.upper = 0.9,
                                                                  probability.lower = 0.1,
                                                                  probability.midpoint = c(0.5,0.2)),
                                                     "MNAR" = list(columns = 1:5,
                                                                   size = 5,
                                                                   probability.upper = 0.05,
                                                                   probability.lower = 0.95,
                                                                   probability.midpoint = c(0.5,0.3))
                                                     )
                              )

```

In principle `data_ImputeBench()` (or `simulation_ImputeBench()`) expects a list of parameter choices (as with `scenarios`, even if only one parameter choice is made. Furthermore, each entry of this list must be itself a list that contains an MCAR, MAR and/or MNAR entry. **All three entries** - MCAR, MAR and MNAR, if specified - are expected to be lists that can feature the entries 

  * `columns`, specifying which columns can be masked MCAR/MAR or MNAR, respectively (default is all columns of `data`), and,
  * `size`, specifying how many columns should be masked MCAR/MAR or MNAR, respectively. In the case `columns` and `size` are specified it is expected that `size` is smaller than the length of `columns`. Default of `size` is `ncol(data)/2`.
  
**Note 2.3**: As in `scenarios` the default only comes into play if **one** parameter of MCAR, MAR or MNAR is specified, respectively. In other words if no `MAR` list is included in the parameter list, then no column is masked via a MAR mechanism.
  
Moreover for **MCAR** one can specify the 

  * `probability` which corresponds one to one to its entry in `scenarios`. Expected is a numeric between 0 and 1. Note that all columns with MCAR - as they are drawn at random - will feature the same `probability`  parameter. Default is `0.25`.

Meanwhile for **MAR** and **MNAR** the same holds true for 

  * `probability.upper`, `probability.lower` and `probability.midpoint`: They correspond one to one to their counterparts in `scenario`. Expected is a numeric between 0 and 1 for `probability.upper` and `probability.lower` and a vector with two numeric entries between 0 and 1 for `probability.midpoint`. Note, as the columns with missing entries are drawn at randomly they all feature the same three `probability._____` parameters. Default is `0.8` for `probability.upper`, `0.2` for `probability.lower` and `c(0.5,0.5)` for `probability.midpoint`.

Last, in **MAR** one can specify:

  * `size.regressors` determining how many regressor columns should be drawn for each MAR column. Expected is a vector of positive integers indicating possible values (in our example the value is `c(1,2)` meaning that there is/are 1 or 2 regressors), the number of regressors is then drawn uniformly over all values in the vector of `size.regressors`. Default is `c(1,2,3)`.


In the case that `missingness_parameters = NULL` (and `scenarios = NULL`) the default parameters are given by

  * `MCAR`: A list with the following details:
    * `columns`: All columns of `data` (or `1:data.size` in the case of simulated data).
    * `size`: Half of the length of `columns`.
    * `probability`: Set to `0.25`.
  * `MAR`: Set to `NULL`.
  * `MNAR`: Set to `NULL`.


**Additional Exported Function**: `data_ImputeBench()` calls internally the function `missingness_scenario_from_parameters()` which is exported and can be used to simulate `scenarios` from `missingness_parameters`. The inputs of `missingness_scenario_from_parameters()` are `missingness_parameters` which expects in contrast to its counterpart in `data_ImputeBench()` only **one** list of parameters (opposed to a list of lists of parameters) and `data`. Moreover, a `seed` can be specified. 

Let us return to our diamonds example and benchmark by the defined `missingness_parameters`:

```{r, echo = TRUE, fig.align = "center"}

Results.3 = data_ImputeBench(data = diamonds.mtrx,
                             repetitions = reps,
                             missingness_parameters = missingness_parameters)

plot_ImputeBench(Evaluation = Results.3$evaluation)
```

Let us look at the missingness pattern:

#### Example {.tabset}

##### color & clarity {.tabset}

###### Scenario 1 - MCAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 1`[[1]]$mask,
                              clms = c(3,4),
                              type = "facets",
                              alpha = 0.7)

```

###### Scenario 2 - MAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 2`[[1]]$mask,
                              clms = c(3,4),
                              type = "facets",
                              alpha = 0.7)

```

###### Scenario 3 - MNAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 3`[[1]]$mask,
                              type = "facets",
                              clms = c(3,4),
                              alpha = 0.7)

```


##### x & y {.tabset}

###### Scenario 1 - MCAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 1`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)

```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_newp_1.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_newp_1.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

###### Scenario 2 - MCAR & MNAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 2`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)

```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_newp_2.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_newp_2.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->

###### Scenario 3 - MAR

```{r, echo = TRUE, fig.align = "center"}

plot_2D_simulated_missingness(data = dm_data,
                              mask = Results.3$data.list$`Parameters 3`[[1]]$mask,
                              clms = c(8,9),
                              alpha = 0.7)


```

<!-- # ```{r} -->
<!-- # htmlwidgets::saveWidget(p, "p_newp_3.html", selfcontained = F, libdir = "lib") -->
<!-- # htmltools::tags$iframe( -->
<!-- #   src = "p_newp_3.html", -->
<!-- #   seamless = "seamless", -->
<!-- #   scrolling = "no", -->
<!-- #   width = "100%", -->
<!-- #   height = "600", -->
<!-- #   frameBorder = "0" -->
<!-- # ) -->
<!-- #  -->
<!-- # ``` -->





## 2.2 How to Add/Remove Imputation Methods

New imputation methods are added to the benchmarking in `data_ImputeBench()` using the argument `methods`. The default of `methods` is `NULL` (adding no methods to the four default ones). If not `NULL` the argument `methods` is expected to be a list of functions taking a specific shape as detailed in Section 2.2.1 further below. The additionally supplied methods of `methods` can be given custom names via naming the list entries. Additionally, one can add a training function for the parameters of the methods supplied with `methods` passed via the argument `training` which itself is expected to be a list of functions (if not `NULL` it is expected to have the same length as `methods`) where each list entry corresponds to the training function of the corresponding (by index) imputation method in `methods`. Details of `training` are given in Section 2.2.2. The inclusion of the four default methods can be customized via the `default_methods` argument, detailed in Section 2.2.3. Moreover, as training for each run of each scenario and all imputation methods might be a computational burdon, via the `retrain_always` arguments one can choose that training should be done once per scenario/parameter choice - this is detailed in Section 2.2.4. Last, in Section 2.2.5 choosing the baseline imputation method via the `baseline_method` argument is discussed.


### 2.2.1 Adding Imputation Methods

The argument `methods` should be passed as a list (even if only one additional imputation method is passed). A list entry in `methods` should be a function taking the two arguments:

  * `data`: The data with missing entries (a numeric matrix with missing entries indicated by `NA`).
  * `args`: A named list of (trainable) arguments. 

The output of the method should be

  * An imputed data matrix (a numeric matrix).

**Note 2.4**: If the output matrix still contains missing entries, these will be by default filled by the `baseline_method` (in the default case median imputation).

#### Example - Definition of the Functions {.tabset}

##### Random Imputation

As an example let us consider imputation by random draw from the empirical distribution of the observed parameters


```{r, echo = TRUE}
wrandom = function(data,
                   args = NULL){
  clms.with.missing.entries = 
    which(matrixStats::colSums2(matrix(as.numeric(is.na(data)), nrow = nrow(data))) != 0)
  imputed.matrix = data
  for(t in clms.with.missing.entries){
    imputed.matrix[is.na(data[,t]),t] = 
      sample(data[!is.na(data[,t]),t], replace = TRUE, size = sum(as.numeric(is.na(data[,t]))))
  }
  return(imputed.matrix)
}
```

##### soft impute (default)

`ImputeBench` includes four default methods which are exported as four wrapper functions `wKNN()`, `wMICE()`, `wsImpute()` and `wmissF()` all calling the respective functions from the packages `VIM`, `mice`, `softImpute` and `missForest`, respectively (see Section 1.5 for details). Displayed below is the wrapper function for soft impute:

```{r, echo = TRUE, eval = FALSE}
wsImpute = function(data,
                    args = list(rank.max = 50,
                                lambda = 2,
                                type = "svd")){
  means = matrixStats::colMeans2(data, na.rm = TRUE)
  sd = matrixStats::colSds(data, na.rm = TRUE)
  data.stdzd = (data - matrix(rep(means, each = nrow(data)), nrow = nrow(data))) /
    matrix(rep(pmax(sd, 0.0001), each = nrow(data)), nrow = nrow(data))
  fits.sI = softImpute::softImpute(data.stdzd ,
                                   rank.max = args$rank.max,
                                   lambda = args$lambda,
                                   type = args$type)
  imputed.matrix = softImpute::complete(data.stdzd, fits.sI)

  imputed.matrix = (matrix(rep(pmax(sd, 0.0001), each = nrow(data)), nrow = nrow(data)) * imputed.matrix) +
    matrix(rep(means, each = nrow(data)), nrow = nrow(data))

  return(imputed.matrix)
}
```

#### Example - Evaluation

Let us include the random imputation in our comparison:

```{r, echo = TRUE, fig.align = "center"}

Results.4 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios,
                             methods = list("random imp." = wrandom))

plot_ImputeBench(Evaluation = Results.4$evaluation)

```


As seen above to add names to the new methods by naming list entries. All added methods with missing names will be named `"Method_x"` with x being their index in `methods`.


### 2.2.2 Adding Parameter Training Functions

If additional imputation methods are specified in `methods` one can pass also training functions for their arguments (`args`) via the argument `training` of `data_ImputeBench()`. As for `methods` the argument `training` is expected to be a list. A list entry in `training` needs to correspond to its matching index in `methods` and is expected to be a function taking as an input `data` and returning a named list `args` that is compatible with the input argument of `args` in the `methods` list entry of the same index.

**Note 2.5**: Adding `training` is necessary if additional methods are added via `methods` that do not except `args = NULL` as an input.

#### Example - `train_sImpute` {.tabset}

As an example consider below the training function used as a default in `data_ImputeBench()` to train the `lambda` of soft impute via a bisection algorithm using once again `simulate_mask()` to draw additional missingness pattern (the training functions of k-nn and soft impute are exported, see Section 1.5 for details).

```{r, eval=FALSE, echo = TRUE}


train_sImpute = function(data){
  # Hard-coded parameters:

  maximal.lambda = 100*(base::min(base::ncol(data),base::nrow(data)))
  minimal.lambda = 0.001*(base::min(base::ncol(data),base::nrow(data)))
  repetitions = 10
  bisection.partition = 10
  bisection.depth = 2
  default.lambda = 5 # The actual default lambda is 0 but that seems not appropriate

  rank.max = base::min(base::ncol(data),base::nrow(data)) - 1 # The actual default is 2, also this seems to be not appropriate.
  type = "svd" # Our chosen default
  max.time = 2592000
  #########################################################################
  # Finding the count and binary columns
  cblist = determine_count_binary(data)
  only.count.columns = base::setdiff(cblist$count.columns, cblist$binary.columns)
  binary.columns = cblist$binary.columns
  # Preparing the lambda vector
  each.trained.lambda = base::rep(c(100), repetitions)
  # We need to initialize an MCAR base scenario
  missingness.scenario = missingness_scenario_from_parameters(nbr_columns = ncol(data),
                                                              missingness_parameters = list("MCAR" = list(columns = 1:ncol(data),
                                                                                                          size = floor(ncol(data)/2),
                                                                                                          probability = 0.2)))
  for(t in 1:repetitions){
    # t = 1
    # print(t)
    # We need to simulate an additional mask
    starting.values = c(minimal.lambda, maximal.lambda)
    new.mask = simulate_mask(data = data,
                             scenario = missingness.scenario)
    # And impose this mask on the data
    masked.data = data
    for(clmn in 1:base::ncol(data)){
      masked.data[base::which(new.mask[,clmn] == 0),clmn] = NA
    }
    for(dep in 1:bisection.depth){
      # print(dep)
      # dep = 1
      # st.pts = seq(from = log(0.01), to = log(1000), length.out = 10)
      # eval.pts = exp(st.pts)
      # evaluation.points = exp(st.pts)
      # starting.values = c(0.01,1000)
      log.evaluation.points = seq(from = log(starting.values[1]),
                                  to = log(starting.values[2]),
                                  length.out = bisection.partition)
      evaluation.points = exp(log.evaluation.points)
      bisection = base::rep(c(100), times = bisection.partition)
      counter = 1
      # rm("imputed_data")
      for(m in evaluation.points){
        # m = 1
        par = list(lambda = m,
                   rank.max = rank.max,
                   type = type)
        # Recommended: Using the try() function together with a time.out as to not get stuck here.
        try(
          R.utils::withTimeout(expr = (
            ddpcr::quiet( expr = (imputed_data = wsImpute(data = masked.data,
                                                          args = par ) ))),
            timeout = max.time, #18000
            onTimeout = "warning", substitute = TRUE),
          silent = TRUE)
        # If the imputation worked we need to adjust count and binary columns:
        if(base::exists("imputed_data")){
          if(!(base::is.null(imputed_data))){
            if(length(only.count.columns) != 0){
              imputed_data[, only.count.columns] = base::pmax(round(imputed_data[ , only.count.columns]), 0 )
            }
            if(length(binary.columns) != 0){
              imputed_data[, binary.columns] = base::pmax( base::pmin( base::round(imputed_data[ , binary.columns]), 1) , 0)
            }
            # And we need to compute the error:
            bisection[counter]  = RMSEscaled_onmask(data = data,
                                                    imputed_data = imputed_data,
                                                    scaling_type = "StandardDev",
                                                    mask = new.mask,
                                                    reduced.output = TRUE)
          } # Note that if the if-clause is not satisfied, i.e. imputation has not worked the error will remain at 100 as initialized.
        }
        counter = counter + 1
      }
      # bisection
      middle = base::which(bisection == base::min(bisection, na.rm = TRUE))
      if(length(middle) == 0){
        middle = bisection.partition/2
      }
      # If middle is a vector, we take the first
      middle = middle[1]
      print(c(starting.values[1],starting.values[2]))
      # Now we need to update the starting values
      starting.values[1] = evaluation.points[base::max(middle-1,1)]
      starting.values[2] = evaluation.points[base::min(middle+1,bisection.partition)]
      print(c(starting.values[1],starting.values[2]))

    }
    each.trained.lambda[t] = evaluation.points[middle]
  }
  # evaluation.points
  # If training never worked:
  if(base::min(bisection) == 100){
    trained.lambda = default.lambda
    warning("soft Impute was not trained properly, due to error or time out.")
  } else{
    # Otherwise:
    trained.lambda = median(each.trained.lambda)
  }
  args = list(lambda = trained.lambda,
              rank.max = rank.max,
              type = type)
  return(args)
}


```

To exemplify the addition of parameter training functions, lets assume we want to compare soft impute for differently chosen `lambda`, e.g. $\lambda=0.1,0.2$ and $0.5$, we can add the `wsImpute()` function three times to the `methods` parameter...

```{r, echo = TRUE}
add.methods = list("sI, lambda = 0.1" = wsImpute,
                  "sI, lambda = 0.2" = wsImpute,
                  "sI, lambda = 0.5" = wsImpute)
```

... and add the following three training functions:

```{r, echo = TRUE}
train.lambda.1 = function(data){
  rank.max = base::min(base::ncol(data),base::nrow(data)) - 1
  return(args = list(lambda = 0.1,
                     rank.max = rank.max,
                     type = "svd"))
} 
train.lambda.2 = function(data){
  rank.max = base::min(base::ncol(data),base::nrow(data)) - 1
  return(args = list(lambda = 0.2,
                     rank.max = rank.max,
                     type = "svd"))
} 
train.lambda.5 = function(data){
  rank.max = base::min(base::ncol(data),base::nrow(data)) - 1
  return(args = list(lambda = 0.5,
                     rank.max = rank.max,
                     type = "svd"))
} 
training = list(train.lambda.1,
                train.lambda.2,
                train.lambda.5)

```

Let us run the experiment:

```{r, echo = TRUE, fig.align = "center"}
Results.5 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios,
                             methods = add.methods,
                             training = training)

plot_ImputeBench(Evaluation = Results.5$evaluation)

# The actual trained lambdas:
Results.5$data.list$`MCAR + MNAR`[[1]]$args[[4]]$lambda
Results.5$data.list$`MCAR + MAR`[[1]]$args[[4]]$lambda
Results.5$data.list$`MCAR + MAR + MNAR`[[1]]$args[[4]]$lambda

```

**Note 2.6**: If `training` is specified it needs to be of the same length as `methods`.

**Note 2.7**: It is possible to use exported functions of the `ImputeBench` package such as `simulate_mask` (see Section Section 2.1.1), `missingness_scenario_from_parameters` (see Section 2.1.2) and `RMSEscaled_onmask` (see Section 2.3.1) in a custom training function.


### 2.2.3 Removing Default Imputation Methods

The argument `default_methods` of `data_ImputeBench()` controls the default imputation methods included in the comparison and is by default set to `c("knn","MICE", "missF","softImpute")`. To remove an imputation method from the default delete it from the default vector of character strings and supply the resulting vector as `default_methods`. For example if we want to only compare soft impute (set and trained `lambda`) in the above experiment, we set:

```{r, echo = TRUE, fig.align = "center"}
Results.5a = data_ImputeBench(data = dm_data,
                             scenarios = scenarios,
                             repetitions = reps,
                             methods = add.methods,
                             training = training,
                             default_methods = c("softImpute"),
                             verbose = FALSE)

plot_ImputeBench(Evaluation = Results.5a$evaluation)

```


### 2.2.4 Retraining of the Imputation Method Parameters

By default for each scenario parameters are trained once, as to avoid overlong computation times. Via setting the argument `retrain_always` as `TRUE` one can train the parameters of the imputation methods for each drawn missingness pattern anew. Let us do this for the last example and see how the always retrained soft impute performs in relation to setting `lambda` fixed:

```{r, echo = TRUE, fig.align = "center"}
Results.6 = data_ImputeBench(data = dm_data,
                             scenarios = scenarios,
                             methods = add.methods,
                             repetitions = reps,
                             training = training,
                             retrain_always = TRUE,
                             default_methods = c("softImpute"),
                             verbose = FALSE)

plot_ImputeBench(Evaluation = Results.6$evaluation)
```



### 2.2.5 Changing the Baseline Imputation Method

The baseline method is set via the argument `baseline_method` in `data_ImputeBench()`, expecting as input a character string. At the moment two choices are supported: `"median"` (default) and `"mean"`. Let us use `"mean"` on our diamonds example

```{r, echo = TRUE, fig.align = "center"}
Results.7 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios,
                             baseline_method = "mean",
                             verbose = FALSE)

plot_ImputeBench(Evaluation = Results.7$evaluation)
```


## 2.3 Further Customizations of the Benchmarking Protocol

This section contains some miscellaneous parameters of the benchmarking protocol that can be tweaked via arguments in `data_ImputeBench()`.

### 2.3.1 Changing the Error Measure/Loss Function

The argument `error_measure` of `data_ImputeBench()` is for now set fixed to its default `"l2"`. In the future there might be more choices supported. The `"l2"` choice corresponds to the RMSE over all missing entries after column-wise standardization (subtraction of mean and division with the standard deviation). To avoid division by zero, we divide by the maximum of the standard deviation and a robustness parameter that can be customized in `data_ImputeBench()` by passing the argument `scaling_robust` (default is `0.1`).

Additionally one can pass the argument `error_grouping`, which is detailed in the following subsection, a grouping of the columns of `data`. In the case a grouping is defined the error is computed for each group of columns individually and the overall error is the mean error over all groups. All (the overall and the group individual) errors are reported in `$evaluation`.


**Additional Exported Function**: The error functions that are exported are `RMSEscaled_onmask` (without groups) and `group_RMSEscaled_onmask` (with groups).

  * `RMSEscaled_onmask` has the following arguments:
    * `data` a numeric matrix.
    * `mask` a binary missingness pattern (the "additional" missingness pattern on which the imputed entries are compared with the ground truth).
    * `imputed_data` an imputed numeric matrix.
    * `scaling_type` the normalization used, either the standard deviation (`"StandardDev"`; default) or the IQR (`"IQR"`).
    * `reduced.output` Whether the number of missing entries (missing as dictated by `mask` but present in `data`) should be reported. Default is `FALSE`
    * `scaling_robust` The robustness parameter for dividing by the standard deviation or the IQR. Default is `0.01`.
  * `group_RMSEscaled_onmask` has the following arguments:
    * `data` a numeric matrix.
    * `mask` a binary missingness pattern (the "additional" missingness pattern on which the imputed entries are compared with the ground truth).
    * `imputed_data` an imputed numeric matrix.
    * `scaling_type` the normalization used, either the standard deviation (`"StandardDev"`; default) or the IQR (`"IQR"`).
    * `error.grouping` A named list of column groups (as numeric vectors), find an example below in 2.3.2.
    * `scaling_robust` The robustness parameter for dividing by the standard deviation or the IQR. Default is `0.01`.
  

### 2.3.2 Adding Variable Groups

To have an evaluation over groups of columns/variables we define groups as in Section 1.1 as a list of column indices. In our case lets make a group for each column to later obtain the error for each columns separately:

```{r, echo = TRUE}
grouping = list("carat" = c(1),
                "cut" = c(2),
                "color" = c(3),
                "clarity" = c(4),
                "depth" = c(5),
                "table" = c(6),
                "price" = c(7),
                "x" = c(8),
                "y" = c(9),
                "z" = c(10))
```

If we supply this group now to `data_ImputeBench()` via the argument `error_grouping` we compute

```{r, echo = TRUE}
Results.8 = data_ImputeBench(data = dm_data,
                             repetitions = reps,
                             scenarios = scenarios,
                             error_grouping = grouping)

```

and can plot the following evaluations.

**Note 2.8**: The overall plot does not (necessarily) correspond to the plot when `error_grouping = NULL` as the error is computed as the mean error over all groups (weighting all groups equally rather than weighting all columns equally).

**Note 2.9**: Supported is for the moment only a grouping of *all* columns, i.e. an `error_grouping` should be a list assigning to all columns a group.

#### Example {.tabset}

##### overall

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation)

```


##### carat

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "carat")

```

##### cut

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "cut")

```

##### color

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "color")

```

##### clarity

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "clarity")

```

##### price

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "price")

```

##### x

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "x")

```

##### y

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "y")

```

##### z

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "z")

```



### 2.3.3 Repetitions of the Scenario/Parameters

Via the argument `repetitions` (default is `5`) one can choose how often each missingness scenario/parameter choice should be repeated.


## 2.4 Technical Arguments of `data_ImputeBench()`

There are four more technical arguments of `data_ImputeBench()` that can be customized:

  * `verbose`: Default is `FALSE`. If chosen to be `TRUE` an command line output is printed each time a run of a scenario is finished.
  * `seed`: Setting a seed, default is `NULL`. Be aware that the imputation methods do not inherit the seed, hence performance might vary for equal seeds.
  * `max_time`: Setting a maximal time that each imputation method has to adhere to. Default is `2592000`.
  * `output_data`: Default is `TRUE`. If chosen to be `FALSE` the output contains only the entry `$evaluation` and not the entry `$data.list`. This can be useful if a lot of draws should be made (high `repetitions` value) and memory allocation needs to be kept low.



## 2.5 Customizing `plot_ImputeBench()` - Part 1

First, note that in Section 2.3.2. we used in `plot_ImputeBench()` the argument `group` to obtain the evaluation on a specific group that was supplied via the `error_grouping` argument to `data_ImputeBench()`. Moreover, one can customize the output plot of `plot_ImputeBench()` by:

  * `title`: Changing the title of the plot. Default is `"Title"`.
  * `norm_by_baseline`: Boolean deciding whether the error of an imputation method or the quotiont of said error with the error of the baseline method should be displayed. Default is `TRUE`.
  * `y_axis`: Changing the y-axis label. If `NULL` (default) the y-axis is label is "(Loss of Model)/(Loss of Baseline)".
  * `color_axis_labels`: Changing the color axis labels. Expected is a vector of character strings of the same length as compared imputation methods (that is length of `methods` plus length of `default_methods`, whose default value is 4).
  * `ylim_bottom` and `ylim_top`: Changing the limits of the y-axis scale. Default values are `NA`.


The two further parameters of `plot_ImputeBench()` namely `x_axis` and `error_type` will be explained in Section 3.5 as they are only used for benchmarking on simulated data.


```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.8$evaluation,
                 group = "carat",
                 y_axis = "Performance Measure",
                 title = "Performance on the Carat Column",
                 color_axis_labels = c("K-nn", "MICE", "missForest", "soft impute"))

```

## 2.6 Extracting an Example via `example_ImputeBench()`

Given an output `Results = data_ImputeBench(...)`, to make it easier to extract the simulated mask and trained parameters included in `Results$data.list`, the ImputeBench packages includes the function `example_ImputeBench()`. The following arguments are passed:

  * `Evaluation`: Expects the output of `data_ImputeBench()` or `simulation_ImputeBench()`.
  * `data`: The data matrix supplied to `data_ImputeBench()` or `NULL` in case of considering the output of `simulation_ImputeBench()`. Default is `NULL`.
  * `parameters`: An integer indicating which scenario/parameter should be extracted (its position in the list `missingness.scenarios` or in the list `missingness.parameters`). Default is `1`.
  * `run`: An integer indicating which run should be extracted. Default is `1`.
  * `imputation_methods`: A vector of strings chosen from `knn`, `MICE`, `missF`, `softImpute` and `median` or `NULL`. In the case some default MVI methods from the list are chosen the extracted missingness pattern is imposed on the `data` (or the extracted simulated data in the case of `simulation_ImputeBench()`) and the respective imputed matrices are computed. If default methods are chosen `imputation_indices` must be provided. If `NULL` the extracted missingness pattern is not imposed on `data` (or the simulated data in the case of `simulation_ImputeBench()`) and no imputed matrix is computed. Default is `c("knn", "MICE", "missF", "softImpute", "baseline")`.
  * `imputation_indices`: A vector of integers of the same length as `imputation_methods`. To extract the fixed/trained parameters of scenario/parameter choice indicated in `parameter` and `run` the function `example_ImputeBench()` must be provided with the queue positions within the MVI methods benchmarked of all methods in `imputation_methods`, for more details see below. Default is `c(1,2,3,4,5)`.
  
Details on how to compute the queue position of a default method (or the baseline method). In the case no additional MVI methods were passed to `data_ImputeBench()` and all default MVI methods were chosen the queue positions are:
  * 1: k-nn impute
  * 2: MICE
  * 3: missForest
  * 4: soft impute
  * 5: baseline imputation
In the case additional models are passed via the `methods` in `data_ImputeBench()` one needs to add the length of the list `methods` to each queue position. For example if all default methods are considered and 4 additional non-default methods were being passed by `methods`, the queue position of `knn` is 5, that of `MICE` is 6, and so on. If not all default methods were passed to `data_ImputeBench()` all "later" default methods respective to the above assignement are moving a place up. For example if we consider all default methods but `missF` and no additional ones, the queue positions of `softImpute` and `baseline` are now 4 and 5, respectively.

The output of `example_ImputeBench()` is a list of two (if `imputation_methods=NULL`) or three entries: The first being the data, the second the missingness pattern and the second being a list of imputed matrices.





# 3 Benchmarking on Simulated Data - `simulation_ImputeBench()`

Conceptually `simulation_ImputeBench()` is very similar to `data_ImputeBench()`, hence, in the following we will not reiterate the arguments that were already detailed in Section 2, but highlight the differences. The main difference is that no `data` input is needed and in fact the argument `data` can not be passed to `simulation_ImputeBench()`. Data is simulated by the simulation protocol defined in RMTBM22 and governed by the argument `data_parameters`, which can not be passed to `data_ImputeBench()`. As with `data_ImputeBench()` we can run `simulation_ImputeBench()` solely on default parameters:


```{r, echo = TRUE, fig.align = "center"}

Results.S1 = simulation_ImputeBench(repetitions = reps)
plot_ImputeBench(Evaluation = Results.S1$evaluation)

```

The output of `simulation_ImputeBench()` is structurally the same as the one of `data_ImputeBench` as it is a list consisting of the entries `$evaluation` and `$data.list`. The only difference is that under `$data.list` one can find for each run under the name `data` the simulated data matrix.



### Example {.tabset}

Let us take a look at the default data and missingness pattern:

#### Example 1

```{r, echo = TRUE, fig.align = "center"}
miss.clms = which( matrixStats::colSums2(Results.S1$data.list$Parameters_1[[4]]$mask) != nrow(Results.S1$data.list$Parameters_1[[4]]$mask))
plot_2D_simulated_missingness(data = Results.S1$data.list$Parameters_1[[4]]$data,
                              mask = Results.S1$data.list$Parameters_1[[4]]$mask,
                              clms = c(miss.clms[1],miss.clms[2]),
                              jitter = 0.2,
                              alpha = 0.7)
```

#### Example 2

```{r, echo = TRUE, fig.align = "center"}
miss.clms = which( matrixStats::colSums2(Results.S1$data.list$Parameters_1[[4]]$mask) != nrow(Results.S1$data.list$Parameters_1[[4]]$mask))
plot_2D_simulated_missingness(data = Results.S1$data.list$Parameters_1[[4]]$data,
                              mask = Results.S1$data.list$Parameters_1[[4]]$mask,
                              clms = c(miss.clms[10],miss.clms[11]),
                              jitter = 0.2,
                              alpha = 0.7)
```

#### Example 3

```{r, echo = TRUE, fig.align = "center"}
miss.clms = which( matrixStats::colSums2(Results.S1$data.list$Parameters_1[[4]]$mask) != nrow(Results.S1$data.list$Parameters_1[[4]]$mask))
plot_2D_simulated_missingness(data = Results.S1$data.list$Parameters_1[[4]]$data,
                              mask = Results.S1$data.list$Parameters_1[[4]]$mask,
                              clms = c(miss.clms[1],miss.clms[10]),
                              jitter = 0.2,
                              alpha = 0.7)


```

### Overview of the Subsection

Let us give an overview of the remainder of this section (subsections in **bold** contain major differences to `data_ImputeBench`, while subsections in *italics* mainly refer to the respective subsections of Section 2):

  * **Section 3.1:** How to change the parameters of the data and the missingness pattern.
  * *Section 3.2:* How to add new imputation methods and remove default ones. We will mainly refer to Section 2.2.
  * *Section 3.3:* How to customize the performance measure and the number of repetitions. We will mainly refer to Section 2.3.
  * *Section 3.4:* How to deal with the remaining input arguments. We will reiterate Section 2.4.
  * **Section 3.5:** How to customize `plot_ImputeBench()` further.
  * *Section 3.6:* How to use `example_ImputeBench()` in the case of simulated data. 

thi
## 3.1 Customizing the Parameters of the Data Simulation and the Missingness Pattern Simulation

To change the parameters of the protocols for the data and the missingness pattern simulation `simulation_ImputeBench()` provides the two arguments `data_parameters` and `missingness_parameters`. If `NULL` both are set to default choices, detailed in Section 3.1.1 and 2.1.2 respectively. If not `NULL` both arguments are expected to be lists (in the case that both are specified of equal length), where each list entry is again a list with specified parameters, detailed in the following. The format is largely the same as in `scenarios`, in fact `missingness_parameters` works identically in `simulation_ImputeBench()` as in `data_ImputeBench()`.

**Note 3.1**: As for missingness scenarios in Section 2.1.1: If not all parameters are specified for a given parameter choice, default ones are filled in.


### 3.1.1 The `data_parameters`

A choice of parameters is a list that can contain the following specifications (For details of the data simulation protocol we refer the reader to RMTBM22):

  * `data.size`: The number of rows of the data ($n$ in RMTBM22). Expected is a positive integer and default is `100`.
  * `data.type`: The number of columns of each data type ($\nu$ in RMTBM22). Expected is a vector of length six of positive integers, whose sum is not $0$. Default is `c(5,5,5,5,5,5)`.
  * `data.shape`: A collection of secondary parameters of the data simulation protocol. Expected is a list with the following entries (missing entries will be filled by default values):
    * `gauss.mean`: A vector with two numeric entries, where the second one has to be positive (mean and standard deviation of the means of the Gaussian columns, $(g_1,g_2)$ in RMTBM22). Default is `c(0,1)`.
    * `gauss.sd`: A vector with two numeric entries, where the first one is supposed to be greater than 0.5 and the second on has to be positive (mean and standard deviation of the truncated normal from which the standard deviation of the Gaussian columns are drawn, $(g_3,g_4)$ in RMTBM22). Default is `c(1,2)`.
    * `pois.lambda`: A positive numeric ($\lambda$ of the Poisson distribution drawing the means of the Poisson columns, $\lambda$ in RMTBM22). Default is `1`.
    * `binary.limits`: A vector of two numeric entries in $(0,1)$ (limits of the uniform distribution drawing the success probabilities of the binary columns, $(b_1,b_2)$ in RMTBM22). Default is `c(0.2,0.8)`.
    * `t.mean`: A vector of two numeric entries, where the second one has to be positive (mean and standard deviation of the means of the t-distributed columns, $(t_1,t_2)$ in RMTBM22). Default is `c(0,1)`.
    * `t.limits`: A vector of two positive integers (greater than $0$; limits of the uniform distribution drawing the degrees of freedom of the t-distributed columns, $(t_3,t_4)$ in RMTBM22). Default is `c(1,20)`.
    * `nl.mean`: A vector of two numeric entries, where the second one has to be positive (mean and standard deviation of the means of the sine-transformed columns, $(\xi_1,\xi_2)$ in RMTBM22). Default is `c(0,1)`.
    * `nl.limits`: A vector of two positive numbers (greater than zero; the limits of the uniform distribution drawing the amplitudes of the sine-transformed columns, $(\xi_3,\xi_4)$ in RMTBM22). Default is `c(10,30)`.
    * `nl.freq`: A vector of four positive numeric entries (greater than zero), where the second entry is greater than the first and the third entry is greater than the first and smaller than the second (parameters of the truncated normal drawing the frequencies of the sine-transformed columns, $(\xi_5,\xi_6,\xi_7,\xi_8)$ in RMTBM22). Default is `c(10,20,15,1)`.
    * `sp.points`: A positive integer that sets how many change points the spline-transformed columns should have ($B$ in RMTBM22). Default is `5`.
    * `incl.group`: Either 0 (not include) or 1 (include) indicating whether the translation group column should be included in the data ($u_{\text{incl}}$ in RMTBM22). Default is `0`.
  * `data.groups`: A positive integer (greater than zero) controlling the amount of translation groups ($U$ in RMTBM22). Default is `1`.
  * `data.groups.distance`: A vector containing two positive numeric entries, where the first one is smaller than the second (limits of the uniform draw of translation factors, $(u_1,u_2)$ in RMTBM22). Default is `c(0.5,1.5)`.
  * `data.non.linearity`: A numeric in $[0,1]$ regulating the non-linearity of the latent model ($\alpha$ in RMTBM22). Default is `0`.
  * `data.spars`: A numeric in $[0,1)$ regulating the sparsity of the precision matrix in the latent model ($\rho$ in RMTBM22). Default is `0.4`.
  * `data.low.dim`: A positive integer smaller than the sum of `data.type` ($q$ in RMTBM22) controlling the latent dimension. Default is `5`.
  * `data.low.dim.groups`: A positive integer smaller than the sum of `data.type` controlling the amount of independently drawn groups ($A$ in RMTBM22). Default is `1`. Note that if `data.size` is not divisble by `data.low.dim.groups` it is recast as `floor(data.size/data.low.dim.groups)*data.low.dim.group`.
  * `data.low.dim.parameters`: A list with three entries:
    * `trunc.parameter`: A vector of four positive numeric entries (greater than zero), where the second entry is greater than the first and the third entry is greater than the first and smaller than the second (parameters of the truncated normal drawing the regression coefficients of the latent model, $(r_1,r_2,r_3,r_4)$ in RMTBM22). Default is `c(0.5,10,2,0.5)`.
    * `mean`: The standard deviation of the mean translations for the different low-dimension groups ($\tilde{\sigma}$ in RMTBM22). Default is `1`.
    * `error.std`: A positive numeric defining the standard deviation of the errors in the latent model ($\sigma$ in RMTBM22). Default is `0.05`.

Let us look at some examples using the exported function `simulate_data()` taking as an input an entry of `data_parameters` (by abuse of notation also called `data_parameters`).

**Additional Exported Function**: The function `simulate_data()` is called in `simulation_ImputeBench()` and can be used to simulate data by the protocol defined in RMTBM22. Note that `simulate_data()` expects **one** set of data parameters, in contrast to `simulate_ImputeBench()` which expects a *list* of such sets of parameters. Additionally one set a `seed` in `simulate_data()`.

#### Examples {.tabset}

##### Data Size {.tabset}

###### 100 (def) 

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 100)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```


###### 1000

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 1000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 10000

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 10000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

##### Data Type {.tabset}

###### Gaussian x Gaussian

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```


###### Gaussian x Poisson

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,6),
             jitter = 0.3,
             alpha = 0.5)
```

###### Poisson x Poisson (non-linear)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(0,10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 0.6)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(6,7),
             jitter = 0.3,
             type = "tile",
             alpha = 0.5)
```

###### Gaussian x Binary

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,11),
             alpha = 0.5,
             jitter = 0.3)
```


###### Gaussian x t

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,16),
             alpha = 0.5)
```


###### Gaussian x sine

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,21),
             alpha = 0.5)
```

###### Gaussian x spline

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,26),
             alpha = 0.5)
```


##### Non-linearity {.tabset}

###### 0 (def)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 0)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 0.25

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 0.25)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 0.5

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 0.5)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 0.75

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 0.75)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 1

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 1)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```

###### 1 (higher low.dim error)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.non.linearity = 1,
                  data.low.dim.parameters = list(error.std = 1))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.5)
```


<!-- I would leave the precision matrix out, maybe we should throw it out completely! It does not make a real difference and thus is hard to argue for anyway.

<!-- ##### Precision Matrix Sparsity {.tabset} -->

<!-- ###### 0.001 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.001) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->

<!-- ###### 0.01 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.01) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->

<!-- ###### 0.1 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.1) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->

<!-- ###### 0.4 (def) -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.4) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->

<!-- ###### 0.9 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.9) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->

<!-- ###### 0.99 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.99) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->


<!-- ###### 0.999 -->

<!-- ```{r, echo = TRUE, fig.align = "center"} -->
<!-- parameters = list(data.size = 2000, -->
<!--                   data.type = c(10,0,0,0,0,0), -->
<!--                   data.low.dim = 10, -->
<!--                   data.spars = 0.999) -->
<!-- sim.data = simulate_data(data_parameters = parameters) -->
<!-- plot_2D_data(data = sim.data, -->
<!--              clms = c(1,2), -->
<!--              alpha = 0.5) -->
<!-- ``` -->


##### Low Dimensionality {.tabset}

As visualizing dimensionality is visualized best up to three dimensions, we consider $q=1,2,p$ in the following.

###### $1$

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 1)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### $2$

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2)
sim.data = simulate_data(data_parameters = parameters)
p = plot_3D_data(data = sim.data,
                 clms = c(1,2,3),
                 alpha = 0.5)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "low_dim_1.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "low_dim_1.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->

###### $p$

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 10)
sim.data = simulate_data(data_parameters = parameters)
p = plot_3D_data(data = sim.data,
                 clms = c(1,2,3),
                 alpha = 0.5)
p
```

<!-- ```{r} -->
<!-- htmlwidgets::saveWidget(p, "low_dim_2.html", selfcontained = F, libdir = "lib") -->
<!-- htmltools::tags$iframe( -->
<!--   src = "low_dim_2.html", -->
<!--   seamless = "seamless", -->
<!--   scrolling = "no", -->
<!--   width = "100%", -->
<!--   height = "600", -->
<!--   frameBorder = "0" -->
<!-- ) -->

<!-- ``` -->


##### Groups {.tabset}

###### 1 (def)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 5,
                  data.groups = 1)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 2

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 5,
                  data.groups = 2)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 4

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 5,
                  data.groups = 4)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### 8

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 5,
                  data.groups = 8)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### 8 (higher translation factor)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 5,
                  data.groups = 8,
                  data.groups.distance = c(10,20))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.1)
```


##### Low Dimension Groups {.tabset}

###### 1 (def)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 1)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 2

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 2)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### 5

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 5)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### 10

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10)
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

##### Projection Means {.tabset}

###### 0

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 0))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 1 (def)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 0))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```



###### 4

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 4))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```



###### 16

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 16))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```



###### 64

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 2,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 64))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```



##### Low Dimension Error {.tabset}


###### 0.005

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 1,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 6,
                                                 error.std = 0.005))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 0.05 (def)

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 1,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 6,
                                                 error.std = 0.05))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```

###### 0.5

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 1,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 6,
                                                 error.std = 0.5))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```


###### 5

```{r, echo = TRUE, fig.align = "center"}
parameters = list(data.size = 2000,
                  data.type = c(10,0,0,0,0,0),
                  data.low.dim = 1,
                  data.low.dim.groups = 10,
                  data.low.dim.parameters = list(mean = 6,
                                                 error.std = 5))
sim.data = simulate_data(data_parameters = parameters)
plot_2D_data(data = sim.data,
             clms = c(1,2),
             alpha = 0.2)
```



#### Example of `simulation_ImputeBench()`


As an example let us pick four of the above parameter choices and plug them into `simulation_ImputeBench()`:

```{r, echo = TRUE, fig.align = "center"}

parameters = list("Default" = list(data.size = 50,
                                  data.type = c(5,5,5,5,5,5),
                                  data.shape = list(gauss.mean = c(0,1) ,
                                                    gauss.sd = c(1,2) ,
                                                    pois.lambda = c(1) ,
                                                    binary.limits = c(0.2,0.8) ,
                                                    t.mean = c(0,1),
                                                    t.limits = c(1,20) ,
                                                    nl.mean = c(0,1) ,
                                                    nl.limits = c(10,30),
                                                    nl.freq = c(10,20,15,1),
                                                    sp.points = 5,
                                                    incl.group = 0),
                                  data.non.linearity = 0,
                                  data.spars    = 0.4,
                                  data.low.dim  = 5,
                                  data.groups = 1,
                                  data.groups.distance = c(0.5,1.5),
                                  data.low.dim.groups = 1,
                                  data.low.dim.parameters =   list(trunc.parameter = c(0.5,10,2,0.5),
                                                                   mean = 1,
                                                                   error.std = 0.05)),
                  "Sphere" = list(data.size = sz.2,
                                  data.type = c(10,0,0,0,0,0),
                                  data.low.dim = 3,
                                  data.non.linearity = 1,
                                  data.low.dim.parameters = list(error.std = 0.8)),
                  "Many Groups" = list(data.size = sz.2,
                                       data.type = c(10,0,0,0,0,0),
                                       data.low.dim = 5,
                                       data.groups = 8,
                                       data.groups.distance = c(1,5)),
                  "Many Low-Dim Groups" = list(data.size = sz.2,
                                               data.type = c(10,0,0,0,0,0),
                                               data.low.dim = 1,
                                               data.low.dim.groups = 10,
                                               data.low.dim.parameters = list(mean = 6,
                                                                              error.std = 0.5)),
                  "Poisson non-linear" = list(data.size = sz.2,
                                              data.type = c(0,10,0,0,0,0,0),
                                              data.low.dim = 2,
                                              data.non.linearity = 0.6))


Results.S2 = simulation_ImputeBench(data_parameters = parameters,                             
                                    repetitions = reps)
plot_ImputeBench(Evaluation = Results.S2$evaluation)

```


If `data.parameter = NULL` four choices of data parameters are passed: All with the default values varying only the input `data.size` over the set `c(50,100,200,400)`.


### 3.1.2 The `missingness_parameters`

Works exactly as described in Section 2.1.2 for `data_ImputeBench()`. Note that `simulation_ImputeBench()` has no argument `scenarios` and thus **only** draws missingness pattern via the argument `missingness_parameters`. Their specification, defaults and nomenclature is exactly the same as in `data_ImputeBench()`.

## 3.2 How to Add/Remove Imputation Methods

Works exactly as described in Section 2.2 for `data_ImputeBench()`. The specification of the arguments `methods`, `training`, `default_methods`, `retrain_always` and `baseline_method` and their effects are exactly the same as in `data_ImputeBench()`.

#### Example

Let us repeat some examples of 2.3 on the simulated data of 3.1.1:

```{r, echo = TRUE, fig.align = "center"}

Results.S3 = simulation_ImputeBench(data_parameters = parameters,
                                    repetitions = reps,
                                    methods = list("random imp." = wrandom))
plot_ImputeBench(Evaluation = Results.S3$evaluation)
```


```{r, echo = TRUE, fig.align = "center"}

Results.S4 = simulation_ImputeBench(data_parameters = parameters,
                                    repetitions = reps,
                                    methods = add.methods,
                                    training = training,
                                    default_methods = c("softImpute"))
plot_ImputeBench(Evaluation = Results.S4$evaluation)

```


## 3.3 Further Customization of the Benchmarking Protocol

The arguments `repetitions`, `error_measure` and `scaling_robust` work in `simulation_ImputeBench()` exactly as their counterparts in `data_ImputeBench()`. For details we thus refer to Section 2.3. The argument `error_grouping` does not exist for `simulation_ImputeBench()`.

**Note 3.2**: By default errors on Gaussian, Poisson, binary (in `error_measure` and log-odds terms), t-distributed, sine-transformed and spline-transformed are collected as well and can be displayed via `plot_ImputeBench()`, see Section 3.5.

## 3.4 Technical Arguments of `simulation_ImputeBench()`

As in `data_ImputeBench()` there are four more technical arguments that can be customized in `simulation_ImputeBench()`:

  * `verbose`: Default is `FALSE`. If chosen to be `TRUE` an command line output is printed each time a run of a scenario is finished.
  * `seed`: Setting a seed, default is `NULL`. Be aware that the methods do not inherit the seed, hence performance might for equal seeds.
  * `max_time`: Setting a maximal time that each imputation method has to adhere to. Default is `2592000`.
  * `output_data`: Default is `TRUE`. If chosen to be `FALSE` the output contains only the entry `$evaluation` and not the entry `$data.list`. This can be useful if a lot of draws should be made (high `repetitions` value) and memory allocation needs to be kept low.

## 3.5 Customizing `plot_ImputeBench()` - Part 2

Additionally to the parameters `title`, `y_axis` and `color_axis_labels` of Section 1.6 we introduce furthermore the parameters

  * `x_axis`: Changing the labels and the title of the x-axis. If not `NULL` (default) one of the following character strings is expected: 
    * `"n"` (referring to `data.size` of `data_parameters`)
    * `"p_gauss"` (referring to the first entry of `data.type` of `data_parameters`)
    * `"p_poisson"` (referring to the second entry of `data.type` of `data_parameters`)
    * `"p_binary"` (referring to the third entry of `data.type` of `data_parameters`)
    * `"p_t"` (referring to the fourth entry of `data.type` of `data_parameters`)
    * `"p_sine"` (referring to the fifth entry of `data.type` of `data_parameters`)
    * `"p_spline"` (referring to the sixth entry of `data.type` of `data_parameters`)
    * `"size_MCAR"` (referring to the length of `columns` of `missingness_parameters$MCAR`)
    * `"size_MAR"` (referring to the length of `columns` of `missingness_parameters$MAR`)
    * `"size_MNAR"` (referring to the length of `columns` of `missingness_parameters$MNAR`)
    * `"probability_MCAR"` (referring to `probability` of `missingness_parameters$MCAR`)
    * `"p"` (referring to the sum of the `data.type` vector of `data_parameters`)
    * `"sparsity"` (referring to `data.spars` of `data_parameters`)
    * `"q"` (referring to `data.low.dim` of `data_parameters`)
    * `"lowdim_error"` (referring to `data.low.dim.parameters$error.std` of `data_parameters`)
    * `"groups"` (referring to `data.groups` of `data_parameters`)
    * `"non_linearity"` (referring to `data.non.linearity` of `data_parameters`)
    * `"low_dim_groups"` (referring to `data.low.dim.groups` of `data_parameters`)
    * `"transl_factor"` (referring to `data.groups.distance` of `data_parameters`)
  * `error_type`: If only the error on a specific data type should be displayed. If not `"overall"` (default) one of the following character strings is expected:
    * `gauss`: For the error on the Gaussian columns.
    * `pois`: For the error on the Poisson columns.
    * `binary.mse`: For the error on the binary columns in root mean squared error terms.
    * `binary.logodds`: For the error on the binary columns in log-odds terms.
    * `t`: For the error on the t-distributed columns.
    * `sine`: For the error on the sine-transformed columns.
    * `spline`: For the error on the spline-transformed columns.
    * `continuous`: All continuous columns, i.e. all columns except Poisson and binary columns.

Let us end this vignette with an example, displaying binary log-odds:

```{r, echo = TRUE, fig.align = "center"}

plot_ImputeBench(Evaluation = Results.S1$evaluation,
                 y_axis = "Imputation Performance by log-odds",
                 title = "Imputation Performance on the Binary Columns",
                 color_axis_labels = c("k-nn", "MICE", "missForest", "soft impute"),
                 x_axis = "n",
                 error_type = "binary.logodds")

```


## 3.6 Extracting an Example via `example_ImputeBench()`

The function `example_ImputeBench()` works on results of `simulation_ImputeBench()` exactly as described in Section 2.6 by passing `data=NULL`. As detailed it outputs the data, the missingness pattern and optional imputated matrices of a specified parameter choice and run.









